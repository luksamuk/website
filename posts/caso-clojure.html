<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt_BR" xml:lang="pt_BR">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Classificando Lisps: O Caso Clojure</title>
<meta name="author" content="Lucas Vieira" />
<meta name="description" content="Programming, Tech, and occasional rant space by Lucas Vieira" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-22RF3F5XE0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-22RF3F5XE0');
</script>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link id="theme-css" rel="stylesheet" type="text/css" href="../css/dark-theme.css" />
<link rel="icon" type="image/jpg" href="../img/cat-i-mage.jpg" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:image" content="../img/cat-i-mage.jpg">
<meta name="theme-color" content="#14171e">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<nav><h1><a href="../">The Alchemist's Hideout</a></h1></nav><h1 class="title">Classificando Lisps: O Caso Clojure</h1><p><i>Escrito em Ago 16, 2019 por Lucas Vieira<br/><a href="mailto:lucasvieira@lisp.com.br">lucasvieira@lisp.com.br</a></i></p>
</div>
<div id="content" class="content">
<div class="abstract" id="org4522da3">
<p>
Clojure é um dialeto moderno de Lisp que possui alta popularidade e
grande uso na indústria. Este dialeto de Lisp utiliza sintaxe e ideias
pouco ortodoxas com relação a outros dialetos mais conhecidos; estas
diferenças são suficientes para que alguns membros da comunidade
de dialetos Lisp questione se Clojure é, realmente, um dialeto de
Lisp. Este artigo pretende expor meu ponto de vista com relação à
linguagem, e também propor uma forma diferente de análise de dialetos
Lisp, substituindo uma visão discreta (ser ou não ser um dialeto de
Lisp) por uma visão descritível em uma escala, que relaciona a
expressividade e a versatilidade dos Lisps tradicionais com a
linguagem comparada. Proponho uma forma de ver Clojure sob esta ótica,
e então mostro como uma comparação polarizada pode ser prejudicial,
tendo em vista críticas baseadas neste ponto de vista antigo.
</p>

</div>


<div id="outline-container-org9c061b2" class="outline-2">
<h2 id="org9c061b2">Introdução</h2>
<div class="outline-text-2" id="text-org9c061b2">
<p>
Você conhece a linguagem Clojure? Costumo falar muito de
linguagens como Common Lisp e Scheme, mas não cheguei a mostrar o que
acho desta primeira. Algumas pessoas perguntam minha opinião a
respeito da mesma, e inclusive me perguntam se realmente considero-a
um dialeto de Lisp.
</p>

<p>
Pois bem, chegou a hora de dar uma dimensão do que penso a respeito de
Clojure. Ressalto desde já que não gosto muito deste tipo de
discussão, em especial porque detesto tratar de tópicos em que a maior
parte da argumentação está atrelada a preferência pessoal. Mas
não minimizo a importância do debate. Estou envolvido com a comunidade
<i>Common Lisp Brasil</i>, e minhas ideias acabam perpassando a forma como
enxergo CL, também. Todavia, que fique bem claro que esta é unicamente
a minha opinião, e que não necessariamente reflete a opinião dos
outros membros da comunidade <i>Common Lisp Brasil</i>.
</p>
</div>
</div>

<div id="outline-container-org6abb40b" class="outline-2">
<h2 id="org6abb40b">A linguagem Clojure</h2>
<div class="outline-text-2" id="text-org6abb40b">
<p>
Clojure é uma linguagem amplamente reconhecida como um dos muitos
dialetos de Lisp. Sua plataforma primária é a <i>Java Virtual
Machine</i>. Seu design foi feito por Rich Hickey, e já ouvi falar que
este design foi feito de forma cuidadosa &#x2013; algo crucial no
desenvolvimento de uma linguagem de programação, e que <a href="https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/">nem sempre é
levado em consideração de verdade</a>.
</p>

<p>
Adicionalmente, Clojure é considerado um dialeto de Lisp pouco
ortodoxo, o que de fato faz com que programadores de outros dialetos
desconfiem das decisões tomadas em seu <i>design</i> &#x2013; inclusive, não estou
isento da realização destes questionamentos. De qualquer forma, é o
dialeto de Lisp atualmente mais utilizado na indústria, tendo
sobretudo seus ramos no Brasil, em empresas como a Nubank, por
exemplo.
</p>
</div>
</div>

<div id="outline-container-org06c5070" class="outline-2">
<h2 id="org06c5070">Experiência pessoal</h2>
<div class="outline-text-2" id="text-org06c5070">
<p>
Sou um programador versátil, e tive contato com várias linguagens
diferentes ao longo da minha vida. Inevitavelmente, desenvolvi uma
opinião forte a respeito das linguagens que eu achava boas, e das
características que eu gostava nestas linguagens. Mas ao ter contato
com outras linguagens e programadores que eram &#x2013; ainda bem! &#x2013; muito
mais razoáveis que eu, aprendi que é necessário um grau de
tolerância para uma opinião madura a respeito do assunto,
juntamente com um toque de pé-no-chão. Em suma, eis algumas máximas
interessantes que explicam parte da minha visão:
</p>

<ul class="org-ul">
<li>De nada adianta uma linguagem que <i>resolve</i> seu problema e não o faz
de forma <i>elegante</i>;</li>
<li>De nada adianta uma linguagem <i>elegante</i> que não <i>resolve</i> seu
problema.</li>
</ul>

<p>
Estas duas frases criam um balanço tênue entre pragmatismo e
expressividade. Admito que parte disso é culpa das escolas de
pensamento do <a href="https://sarabander.github.io/sicp/">SICP</a> e da <a href="https://pt.wikipedia.org/wiki/Filosofia_Unix">Filosofia UNIX</a>, das quais gosto muito.
</p>

<p>
Quando falo em <i>elegância</i>, estou me referindo ao conceito de criação de
peças simples que se conectam para uma funcionalidade mais complexa. Em
outras palavras, refiro-me a conceber componentes pequenos, que
interagem de forma transparente. Isto também pode ser compreendido
através da ideia de <i>robustez</i>, mas o conceito de <i>elegância</i> não
significa que todo e qualquer <i>software</i> feito em uma linguagem com esta
característica seja, necessariamente, <i>robusto</i>.
</p>

<p>
<i>Software</i> demanda trabalho e análise cuidadosa e não se cria da noite
para o dia, então boa parte da <i>robustez</i> de um <i>software</i> depende apenas
do programador; a linguagem <i>elegante</i> apenas possibilita que o
programador crie <i>software</i> robusto com maior facilidade.
</p>

<p>
O que quero dizer com este raciocínio é que o desenvolvimento do seu
<i>software</i> deve levar em consideração tanto a utilidade quanto a
manutenção; e quando falamos em manutenção, exigimos robustez no
<i>software</i> analisado, para que esta atividade seja facilitada. No
entanto, o que vejo por aí é que algumas soluções desenvolvidas no
mercado (sobretudo para desenvolvimento web) esqueceram-se disso, e
tornaram-se um arranjo de bugs e problemas escorrendo por todos os
cantos. Mas este é um tópico para outro dia.
</p>
</div>
</div>

<div id="outline-container-org0bf217a" class="outline-2">
<h2 id="org0bf217a">Clojure é um Lisp, afinal?</h2>
<div class="outline-text-2" id="text-org0bf217a">
<p>
Um ponto interessante é o quanto o design de Clojure desvia-se de
outros Lisps. Já vi pessoas chamarem Clojure de linguagem <i>Lisp-like</i>,
sugerindo que esta seja uma linguagem que emula a sintaxe de um Lisp
mas não o é. Acredito que esta opinião seja injusta. Para
contra-argumentar, eu mantinha minha própria lista arbitrária de
opiniões a respeito do que caracteriza uma linguagem como Lisp.
</p>

<p>
Todavia, percebi que esta lista arbitrária era uma péssima ferramenta
de análise da linguagem, assim como tantas outras listas arbitrárias
de características já boladas por outros internautas. Resolvi
descartá-la, em prol de uma aproximação muito melhor que já exponho a
seguir. Inclusive, esta discussão acerca de "o que é ou não Lisp" já
causou <a href="https://groups.google.com/d/topic/comp.lang.lisp/Bj8Hx6mZEYI/discussion">brigas homéricas em listas de e-mails</a>, drama que não pretendo
escavar ou reproduzir através deste artigo. De qualquer forma, ficar
classificando linguagens entre Lisp e não-Lisp não é algo tão
valoroso, <a href="http://journal.stuffwithstuff.com/2013/07/18/javascript-isnt-scheme/">exceto em casos muito extremos</a><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>; mais valoroso ainda é
determinar o quanto a linguagem retém do que se espera de um Lisp,
como coloco a seguir.
</p>
</div>

<div id="outline-container-org7761042" class="outline-3">
<h3 id="org7761042">Classificando Lisps</h3>
<div class="outline-text-3" id="text-org7761042">
<p>
Mesmo considerando Clojure um Lisp, ainda me parece insatisfatória
essa classificação discreta. Estou muito inclinado a aceitar este
ponto de vista, mas algumas linguagens, que clamam ser dialetos de
Lisp, são mais difíceis eu engolir. Um exemplo gritante do que
considero um pseudo-Lisp é LFE (<i>Lisp Flavored Erlang</i>). Eu gosto de
usar LFE, e seu uso melhorou a escrita de alguns programas meus, mas
vejo LFE como nada mais que Erlang em pele de Lisp<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.
</p>

<p>
Parece-me que existe uma escala, onde os "Lisps Raiz"  e os "Falsos
Lisps" colocam-se<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>. Mas o que exatamente esta escala mede?
</p>

<p>
O Eduardo Lopes, da <i>Common Lisp Brasil</i>, me deu uma ideia interessante
quanto a isso: ao invés de nos perguntarmos <i>"Linguagem X é um Lisp?"</i>,
devemos nos perguntar <i>"Linguagem X conserva o poder expressivo e a
versatilidade originais dos Lisps?"</i>. Assim, poderíamos ter uma boa
base de debate, e ao mesmo tempo abster-nos de discussões
improdutivas.
</p>

<p>
Antes de aplicarmos este conceito, é interessante que eu explicite o
que entendo como <i>"poder expressivo"</i> e <i>"versatilidade"</i> de Lisp, que não
necessariamente seguem o mesmo entendimento do
Eduardo. Expressividade, para mim, está diretamente associada a
sintaxe; isto envolve ter sintaxe simples e não-ambígua, mas que ainda
assim permita extensão irrestrita. E veja que este poder chega ao
ponto em que, para expressões subsequentes que foram construídas por
esta base expressiva, a simplicidade e não-ambiguidade das mesmas
ficam à mercê do bom-senso do programador<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>.
</p>

<p>
A versatilidade estaria associada ao aspecto da homoiconicidade que, a
meu ver, transita entre sintaxe e semântica: ainda que tenhamos listas
como elementos sintáticos que permeiam a escrita, temos também as
mesmas listas como estruturas manipuláveis, na semântica dos
programas. Em outras palavras, Lisps são versáteis porque o que você
declara sintaticamente é uma estrutura de dados, que é interpretada
como tal, e pode ser manipulada, inclusive em <i>runtime</i>.
</p>

<p>
Agora sim podemos retornar à escala, e dizer que os "Lisps Raiz" são
as linguagens que melhor conservam o poder expressivo e a
versatilidade de <i>LISP 1.5</i>. Entre estas, alegremente coloco dialetos
desaparecidos como <i>ZetaLisp</i>, <i>Maclisp</i>, <i>Interlisp</i>, <i>Lisp Machine Lisp</i>
(das máquinas da Symbolics, por exemplo); também coloco <i>Common Lisp</i> e
<i>Emacs Lisp</i>. <i>Scheme</i> e <i>Racket</i> ficariam um pouco mais longe de <i>LISP 1.5</i>,
mas ainda estariam ali, firmes e fortes.
</p>

<p>
Clojure, então, eu veria como algo que transita para o meio da
escala. Independentemente da conveniência do <i>design</i> da linguagem, esta
ainda quebra muitas convenções de <i>expressividade</i> e <i>versatilidade</i> que
foram pré-estabelecidas nos dialetos anteriores. Clojure não deriva de
nenhum dialeto anterior de Lisp em particular; Common Lisp e Emacs
Lisp tiveram dialetos muito inspirados em <i>LISP 1.5</i> como
precursores.
</p>

<p>
Sendo assim, Clojure tem uma característica forte de rompimento com
toda uma cultura da família de linguagens. Isto não é algo
necessariamente prejudicial, mas deixa claro um bom motivo para o
gosto amargo que o dialeto poderia deixar na boca de programadores
Lisp mais experientes.
</p>
</div>
</div>
</div>

<div id="outline-container-orgefe76cb" class="outline-2">
<h2 id="orgefe76cb">Raiva comunitária</h2>
<div class="outline-text-2" id="text-orgefe76cb">
<p>
Como um último tópico, eu gostaria de analisar um pouco as discussões
e respostas negativas que se colocam ao redor da linguagem Clojure,
sobretudo considerando o que vi <a href="http://www.loper-os.org/?p=42">neste post</a>. Vou tentar conciliar com
críticas tanto aos programadores Lisp mais "tradicionais" quanto aos
programadores Clojure que se manifestaram. Obviamente, não foram
opiniões salutares, e não capturam a totalidade de nenhuma
comunidade.
</p>

<p>
Utilizo o termo <i>"tradicionais"</i> com certo resguardo, pois o autor da
postagem em questão também deixa claro que acha <i>Common Lisp</i> uma
<i>"abominação"</i>, e tenta comparar Clojure à experiência que o mesmo
teve com máquinas da Symbolics. Pessoalmente, nunca utilizei uma Lisp
Machine, mas ainda pretendo fazê-lo e escrever a respeito.
</p>

<p>
Deixo também claro que estes comentários datam de 2012, tendo
completado sete anos no momento de escrita deste post. Opiniões podem
ter mudado, e eu posso estar <i>chutando cachorro morto</i> e fazendo papel
de <i>advogado do diabo</i> ao mesmo tempo.
</p>
</div>

<div id="outline-container-org599d2b7" class="outline-3">
<h3 id="org599d2b7">O "lado" clojurista</h3>
<div class="outline-text-3" id="text-org599d2b7">
<blockquote>
<p>
"Posts like these are the reason I was never interested in being a
part of the CL community. If you want this dream to come true, start
playing the f****** game."
</p>
</blockquote>

<p>
O autor deixa claro, como expliquei anteriormente, que seu objetivo
não é fazer com que interessados em Lisp converjam para Common Lisp ao
invés de Clojure. Ao invés disso, ele tenta apontar, ainda que não
seja de forma adequada, que existe um legado que Clojure parece não
respeitar, e por isso ele não acha Clojure um bom Lisp.
</p>


<blockquote>
<p>
"&#x2026;make Common Lisp libraries that solve real problems&#x2026;"
</p>
</blockquote>

<p>
Atualmente, há bibliotecas em Common Lisp para resolver uma gama de
problemas ditos "reais"<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>. A comunidade japonesa de Common Lisp, em
particular, está muito ativa atualmente, e cria ferramentas muito
boas, desde servidores web de baixa latência a formas de distribuição
e instalação de software escrito em Common Lisp (veja <a href="https://github.com/roswell/roswell">Roswell</a>).
</p>

<blockquote>
<p>
"&#x2026;most of its libraries are undocumented, half-implemented hacks&#x2026;"
</p>
</blockquote>

<p>
Este é definitivamente um dos problemas mais sérios da comunidade de
Common Lisp. Muitas das ferramentas pecam enormemente em documentação
(o autor tenta negar isto em seus comentários). Este problema e seus
possíveis motivos foram abordados por Rudolf Winestock em seu famoso
artigo <a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html">The Lisp Curse</a>, que deixo como leitura adicional ao invés de
tentar repetir o que está exposto nele.
</p>

<blockquote>
<p>
"I can't build usable software in CL anywhere near as short a time as
I can with Java"
</p>
</blockquote>

<p>
Tomando muito cuidado aqui, vou dizer que, se esta frase descreveu uma
experiência genuína, então havia algum problema com a forma de
desenvolvimento da pessoa que a escreveu. Tive a experiência de
desenvolver alguns projetos em Common Lisp, incluindo um pequeno
compilador. Este pequeno compilador possuía um modelo para que fosse
desenvolvido em Java passo-a-passo.
</p>

<p>
Ao invés de utilizar-me do modelo exposto no material didático que
segui, arquitetei o <i>software</i> da forma como eu quis e, com uma boa dose
de organização, pude perceber que os ciclos de teste eram extremamente
mais rápidos que qualquer aplicação que eu já tivesse feito com Java
ou C++; o mero fato de ter um REPL à disposição e reinterpretação
seletiva de definições já tornou muito fácil e rápida a depuração de
problemas e os testes locais.
</p>

<p>
Este é um argumento anedótico, é claro, mas satisfatório como resposta
para outro argumento anedótico. Ainda assim, caro leitor, é mais
interessante que você mesmo analise as potencialidades de Java e
Common Lisp e <a href="http://alchemist.sdf.org/posts/oop-java-vs-cl.html">tire suas próprias conclusões</a>, ao invés de acatar as
minhas.
</p>
</div>
</div>

<div id="outline-container-org529ed07" class="outline-3">
<h3 id="org529ed07">O "lado" tradicional</h3>
<div class="outline-text-3" id="text-org529ed07">
<blockquote>
<p>
"Common Lisp is a Stradivari violin, not a kazoo. It simply isn't for
you&#x2026;"
</p>
</blockquote>

<p>
Considero esta uma resposta muito ruim, e também é o tipo de
pensamento que fazemos questão de não cultivar na <i>Common Lisp
Brasil</i>. Todo e qualquer programador com interesse em Common Lisp
deveria ser bem-vindo à comunidade. Há pessoas na comunidade
brasileira que simpatizam e que não simpatizam com Clojure, algumas
até mesmo utilizam a linguagem no trabalho.
</p>

<p>
Se alguém considera Common Lisp melhor que Clojure, o ideal é mostrar
a opinião de maneira respeitosa e intelectualmente honesta.
</p>

<blockquote>
<p>
"F*** your so-called 'facts of life'. Superior mind-amplifying tools
existed and will exist again."
</p>
</blockquote>

<p>
Falar de Lisps antigos (e também de Common/Emacs Lisp) como
ferramentas superiores e amplificadoras de mentes soa pedante, mas por
trás desta agressividade (totalmente desnecessária, diga-se de
passagem), podemos destacar o ponto do autor: sua maior crítica é
dizer que Clojure é uma linguagem que encoraja o programador a não
importar-se com a forma como as coisas funcionam por baixo.
</p>

<p>
Esta ideia parece contra-intuitiva do ponto de vista de uma linguagem
de alto-nível, mas o que o autor explica é que mesmo Lisps como Common
Lisp possuem um senso de "construção" na constituição de seus
elementos, uma ideia bem palpável do que possibilita a abstração que
você está escrevendo na tela; e para ele, em Clojure, você apenas
escreve o que ele chama de <i>"magia negra"</i> e se dá por vencido. Para
todos os efeitos, aqui entram as ideias de <i>robustez</i>, <i>simplicidade</i> e
<i>versatilidade</i>, construídas por uma linguagem suficientemente
<i>expressiva</i>. Estes aspectos foram discutidos anteriormente.
</p>

<p>
É importante lembrar que esta característica das ferramentas de
desenvolvimento em particular &#x2013; independentemente de ser algo
realmente observável em Clojure ou não &#x2013; é o curso do
desenvolvimento de software na indústria, que já perdura por décadas,
não sendo um problema apenas da comunidade Lisp. Infelizmente, alguns
desenvolvedores (e muitas empresas!) não se importam com robustez em
seu <i>software</i>, e um <a href="https://www.freecodecamp.org/news/we-fired-our-top-talent-best-decision-we-ever-made-4c0a99728fde/">famigerado Programador Rick</a> (ou um programador
incompetente, mesmo) que vier resolver um problema grave de
infraestrutura e performance, passando por cima de boas práticas, será
coroado como heroi.
</p>

<blockquote>
<p>
"&#x2026;the Clojure community still replies to the criticisms therein
with&#x2026; only insults. This is what comes of a product fundamentally
brain-damaged at birth."
</p>
</blockquote>

<p>
Não há algo para ser escavado nesta mensagem, que está logo no topo do
texto, mas eu gostaria de apontar apenas que esta é uma alfinetada
proveniente do autor, que consequentemente só gera mais comentários
raivosos de entusiastas de Clojure. Interessante notar que aqui
perdura a máxima <i>"não existe marketing negativo"</i>, porque este ataque
extra só atrai mais acessos, e que uma postagem ou comentário raivosos
tendem a não atrair uma discussão sensata; este curso de ação pode ser
observado através dos comentários ali deixados.
</p>

<blockquote>
<p>
"The cult of Good Enough which seems to pervade all of modern
computing has finally chewed its way through to the Lisp community"
</p>
</blockquote>

<p>
Esta passagem possuía, originalmente, um link para o texto
<a href="https://www.jwz.org/doc/worse-is-better.html">The Rise of "Worse is Better"</a>, de Richard Gabriel. Esta filosofia
curiosa busca tomar a Filosofia UNIX e dobrá-la em um outro eixo,
colocando a simplicidade de interface e implementação com maior peso
que outros atributos da Filosofia UNIX, como consistência e
corretude.
</p>

<p>
Não pretendo entrar no mérito da validade desta ideia, mas gostaria de
discutir a expressão <i>"Cult of Good Enough"</i>. A meu ver, ela tem duas
conotações: a primeira, mais óbvia e pretendida pelo autor, diz
respeito ao <i>software</i> feito "nas coxas" (vide meu comentário para a
citação sobre <i>"facts of life"</i>).
</p>

<p>
Mas, nesta expressão, há também outra conotação: a ideia do <i>comodismo</i>,
que é onde o argumento do autor do texto sai pela culatra, e que
pode contaminar a impressão que um programador de outros dialetos
de Lisp tem sobre Clojure (veja, isto também inclui a mim). O que
parece <i>bom o suficiente</i> aos nossos olhos tende a sugerir estagnação,
a ponto de tornar-se desgosto por novas sugestões. Até onde estamos
disponíveis para perceber coisas novas?
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe77a42" class="outline-2">
<h2 id="orgbe77a42">Conclusão</h2>
<div class="outline-text-2" id="text-orgbe77a42">
<p>
Este último pensamento coloca na mesa o local onde eu gostaria de
chegar, e também soma-se ao que falei anteriormente para mostrar a
totalidade do meu ponto de vista.
</p>

<p>
Lisps são linguagens maleáveis por definição. Talvez isto seja
proveniente da cultura, talvez seja proveniente da homoiconicidade, ou
de qualquer aspecto mostrado antes, mas esta maleabilidade é melhor
percebida na forma como as ferramentas são construídas ao utilizar a
linguagem. O programador Lisp experiente é capaz de entrar em um
<a href="https://pt.wikipedia.org/wiki/Fluxo_(psicologia)">estado de fluxo</a> muito rapidamente, uma vez que a expressão sintática
fica de lado e dá espaço à semântica dos programas.
</p>

<p>
Todavia, esta maleabilidade também demanda um bom nível de
receptividade ao novo, porque ela vem normalmente acompanhada de um
processo criativo. <i>LISP 1.5</i> foi originalmente criada para lidar com
inteligência artificial, e McCarthy acreditava que Lisp era uma forma
superior de realizar computação, por ser sintaticamente
simples<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>. Mas uma família de linguagens tão poderosa não
necessariamente faz com que seus programadores tenham uma mente
maleável com relação a novas ideias.
</p>

<p>
Ressalto também que uma mente aberta não pressupõe esquecer suas
origens. Criar algo novo envolve obter conhecimento do que veio
antes, para percebermos as coisas boas que foram feitas e que podem
ser reaproveitadas. O paradigma funcional em geral, por exemplo, não é
algo novo, mas foi redescoberto quando percebeu-se que <i>software</i>
predominantemente feito de forma funcional escala muito bem, quando
colocado em conjunto com programação concorrente, <i>clusters</i> ou até
microsserviços.
</p>

<p>
Cabe aos seres sensatos das comunidades de programação o ato de
<i>inventar sem reinventar</i>: Tomar o que há de bom, e mudar o que
verdadeiramente não está bom. Assim, talvez finalmente percebamos que
não existe bala de prata em desenvolvimento de <i>software</i>, e que sempre
haverá espaço para experimentação com boas ideias, sejam elas novas ou
não-tão-novas-assim.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Notas de Rodap&eacute;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
O importante aqui é lembrar que existem linguagens que
simplesmente <b>não são</b> Lisps. JavaScript é uma dessas linguagens, e é o
motivo de eu ter adicionado o link referenciado.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Se não me engano, este é exatamente o propósito de LFE: não
ser um Lisp de fato, mas promover uma melhor escrita de programas em
Erlang através de uma sintaxe similar a Lisp. 
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Linguagens como JavaScript não estão convidadas para a escala,
sinto muito. Aqui só entram linguagens que poderiam se passar por
Lisps; e deixo aqui esta definição vaga de forma proposital, porque
percepção é subjetiva, e portanto cabe debate.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Saliento que este conceito de <i>simplicidade</i> é um apelo ao fluxo
sintático, e não necessariamente à forma como a linguagem foi
projetada. Em outras palavras, se é possível ser extremamente
expressivo com pouca e inteligível escrita e, se isto não for
possível, se há liberdade para que o programador crie a própria forma
de expressão sintática.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Confesso que já ouvi o termo <i>"problemas reais"</i> mais de uma vez,
e ainda não o compreendo; se há um problema que demanda uma solução
tecnológica, ele só pode ser real. Um problema que não seja real me
parece indicativo de necessidade de consulta psiquiátrica. Normalmente
este termo é jogado ao vento por gerentes de projeto que se entitulam
muito pragmáticos, para designar os problemas que não pertencem ao
escopo do <i>software</i> desenvolvido pela empresa onde trabalham.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<i>"McCarthy wanted to show that Lisp was a superior way to describe computation; he thought that the best way to do that was to create the 'universal Lisp function'".</i>
Em <a href="https://lwn.net/Articles/778550/">Lisp and the foundations of computing</a>, parágrafo 16.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<h3><a href="../">De volta à página anterior</a></h3>
</div>
</body>
</html>
