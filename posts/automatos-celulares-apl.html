<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt_BR" xml:lang="pt_BR">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Programando Autômatos Celulares em APL</title>
<meta name="author" content="Lucas S. Vieira" />
<meta name="description" content="Programming, Tech, and occasional rant space by Lucas Vieira" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-22RF3F5XE0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-22RF3F5XE0');
</script>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link id="theme-css" rel="stylesheet" type="text/css" href="../css/dark-theme.css" />
<link rel="icon" type="image/jpg" href="../img/cat-i-mage.jpg" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:image" content="../img/cat-i-mage.jpg">
<meta name="theme-color" content="#14171e">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<nav><h1><a href="../">The Alchemist's Hideout</a></h1></nav><h1 class="title">Programando Autômatos Celulares em APL</h1><p><i>Escrito em Abr 21, 2020 por Lucas S. Vieira<br/><a href="mailto:lucasvieira@protonmail.com">lucasvieira@protonmail.com</a></i></p>
</div>
<div id="content" class="content">
<p>
Neste    post,     pretendo    tratar    de     Autômatos    Celulares
unidimensionais. Adquiri há alguns meses uma cópia do livro <i>A New Kind
of Science</i>, de  Stephen Wolfram. Enquanto não tenho  ainda uma opinião
definitiva sobre o livro (já que não o terminei), acho particularmente
interessante  o  tópico  dos  autômatos  celulares.  Incentivado  pela
leitura  deste  livro, procurei  desenvolver  um  pequeno conjunto  de
funções  que   tornasse  possível   inspecionar  alguns   autômatos  e
imprimi-los na tela.
</p>

<p>
Bem,   na  minha   opinião,   como   ACs  unidimensionais   baseiam-se
primariamente  em <i>vetores</i>,  nenhuma linguagem  seria melhor  de tratar
deste problema que APL. Não  pretendo fazer um discurso advogando esta
linguagem,  mas   uso-a  primariamente   porque  os   programas  ficam
extremamente sucintos;  cada função  é como uma  expressão matemática,
economizando linhas. E eu particularmente acho APL muito bonita.
</p>

<p>
Para os exemplos a seguir, utilizarei  <a href="https://www.dyalog.com/">Dyalog APL</a> ao invés de GNU APL,
porque já me acostumei com este primeiro dialeto.
</p>

<p>
Ah! Este post é uma espécie  de "tutorial rápido" de APL. Ao contrário
do que já fiz anteriormente por aqui, desta vez, vou explicar o
passo-a-passo  das  operações  mais   simples,  para  que  você  possa
compreender melhor a linguagem.
</p>

<div id="outline-container-org9764d43" class="outline-4">
<h4 id="org9764d43">ACHTUNG!</h4>
<div class="outline-text-4" id="text-org9764d43">
<p>
Já falei disso no meu <a href="./usando-apl">último post sobre APL</a>, mas é importante que você
tenha uma <i>fonte compatível instalada</i> no seu dispositivo ou computador.
Por exemplo, veja se esta imagem&#x2026;
</p>


<div id="org234f5dd" class="figure">
<p><img src="img/apl-characters-2.png" alt="apl-characters-2.png" />
</p>
<p><span class="figure-number">Figura 1: </span>Uma expressão em Dyalog APL.</p>
</div>

<p>
&#x2026;corresponde ao código a seguir:
</p>

<pre class="example" id="org4c55fd4">
{1+⊃+/((-⍺-(⌊⍺÷2))+⍳⍺)⌽¨(⌽2*¯1+⍳⍺)×¨⊂⍵}
</pre>

<p>
Se você não  conseguir ver os caracteres no exemplo  acima, então você
não conseguirá ler o restante deste post. Se este for o caso, recomendo
utilizar a fonte GNU FreeFont, ou alguma das fontes recomendadas para
Dyalog APL <a href="https://www.dyalog.com/apl-font-keyboard.htm">que estão aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org2ecfe3c" class="outline-2">
<h2 id="org2ecfe3c">ACs Unidimensionais</h2>
<div class="outline-text-2" id="text-org2ecfe3c">
<p>
Vamos  repassar um  pouco  sobre o  que são  <i>autômatos  celulares</i> e  a
importância  deles.   Repetindo   um  pouco  o  que   já  disse  <a href="../talks/slide-apres-tc.html">nesta
apresentação</a>, autômatos  celulares são sistemas dinâmicos  discretos e
espacialmente estendidos, que têm sido estudados extensivamente como
modelos     de    processos     físicos     e    como     dispositivos
computacionais<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.  Focando  neste   mesmo  aspecto  computacional,
podemos enxergar ACs como uma  forma de falar de computação paralela,
de uma forma bem rudimentar.
</p>

<p>
Como estamos  tratando de ACs  unidimensionais, imagine que  temos uma
fita, completamente dividida em partes  iguais. Cada uma destas partes
será uma <i>célula</i>.
</p>

<p>
A seguir,  para os propósitos  do nosso experimento, imagine  que esta
fita tem seu  fim e seu início conectados, sendo  portanto <i>circular</i> &#x2013;
ou seja, imagine que esta fita está  ao redor de uma lata, de um jeito
que não  possamos identificar  qual é  a primeira  ou a  última célula
dela (vide Figura <a href="#orgb2a9b59">2</a>).
</p>


<div id="orgb2a9b59" class="figure">
<p><img src="img/ac-torus.png" alt="ac-torus.png" />
</p>
<p><span class="figure-number">Figura 2: </span>Exemplo de uma fita circular de células. Cada número nas células representa o estado da célula atual.</p>
</div>

<p>
Em cada parte desta fita, teremos  um número, que representa o <i>estado</i>
de sua célula. Para facilitarmos, tomaremos o número <code>0</code> representando o
estado de uma célula <i>morta</i>, e o número <code>1</code> representando o estado de uma
célula <i>viva</i>.
</p>

<p>
Adicionalmente,  teremos <i>regras  fixas</i> baseadas  na vizinhança  de uma
certa célula,  que definirão qual  será o  estado da mesma  no próximo
passo de tempo. Ou seja, para  sabermos se uma célula permanecerá <i>viva</i>
ou <i>morta</i>,  levamos em consideração  seu <i>atual  estado</i> e os  estados de
seus vizinhos à  <i>esquerda</i> e à <i>direita</i> (em  outras palavras, trataremos
de uma vizinhança de três células).
</p>

<p>
Vou  começar criando  uma <i>fita</i>  deste tipo,  em APL.  Para tanto,  vou
representá-la em um vetor:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">r<span style="color: #9d81ba;">&#8592;</span><span style="color: #0D9C94;">&#175;5</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>
</pre>
</div>

<p>
Se  isto pareceu  estranho, não  se  preocupe. Explicarei  o que  está
acontecendo logo a seguir.
</p>
</div>

<div id="outline-container-org060e0bf" class="outline-3">
<h3 id="org060e0bf">Destrinchando a criação do vetor</h3>
<div class="outline-text-3" id="text-org060e0bf">
<p>
Vamos parar  um pouco. Vou  tentar mostrar de  uma forma melhor  o que
estou fazendo.
</p>

<p>
APL, como  eu disse, envolve  criar <i>expressões</i> que façam  a computação
que precisamos. Assim, programar em APL é algo incremental, no sentido
de que escrevemos expressões simples e vamos adicionando operações até
que os dados tornem-se o que precisamos.
</p>

<p>
A expressão a seguir
</p>

<div class="org-src-container">
<pre class="src src-dyalog"><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Cria, com  ajuda da  função <i>rho</i>  (<code>⍴</code>), um vetor  de 10  elementos, onde
todos são zeros:
</p>

<pre class="example" id="org6b522d5">
0 0 0 0 0 0 0 0 0 0
</pre>

<p>
Em seguida,  <i>catenamos</i> um número  <code>1</code> ao início deste  vetor, aumentando
seu tamanho, e transformando-o em um vetor de 11 elementos, onde todos
os  números são  zeros,  exceto  o primeiro:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Veja  que esta  operação  envolve reescrever  a expressão  adicionando
algo. Isto é facilitado no ambiente de Dyalog APL, pois podemos voltar
a expressões, reescrevê-las  e fazer com que o  ambiente as interprete
ao final, como se tivessem sido ali escritas.
</p>

<p>
Em geral, a expressão escrita possuirá sempre um recuo à sua esquerda,
enquanto  seu resultado  estará logo  abaixo, sem  recuo. Usarei  esta
escrita aqui,  pois ela se  assemelha ao console interativo  de Dyalog
APL e de GNU APL.
</p>

<p>
Em seguida, lembre-se  de que este vetor representa,  na realidade, um
<i>cilindro</i>  (como visto  na Figura  <a href="#orgb2a9b59">2</a>). Assim,  se rotacionarmos
este cilindro  <b>cinco células para  a direita</b>, colocaremos o  número <code>1</code>,
que estava no início, no exato <b>meio</b> do nosso vetor.
</p>

<p>
Isto pode ser feito com uma rotação horizontal (<code>⌽</code>) de <code>-5</code> casas no
vetor. Veja como APL faz isso:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #0D9C94;">&#175;5</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
A  única coisa  restante  é salvar  este vetor  em  uma variável,  que
daremos o nome de <code>r</code>.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">r<span style="color: #9d81ba;">&#8592;</span><span style="color: #0D9C94;">&#175;5</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4504c2" class="outline-2">
<h2 id="orgc4504c2">ACs em APL</h2>
<div class="outline-text-2" id="text-orgc4504c2">
<p>
Agora que  temos um  vetor no qual  podemos testar  nossos algoritmos,
vamos  programar   algumas  regras  básicas  de   autômatos  celulares
unidimensionais que possamos utilizar também.
</p>
</div>

<div id="outline-container-org1323de0" class="outline-3">
<h3 id="org1323de0">Rule 90</h3>
<div class="outline-text-3" id="text-org1323de0">
<p>
A <i>Rule 90</i> é uma regra interessante, porque é capaz de gerar um <a href="https://pt.wikipedia.org/wiki/Fractal">fractal</a>
chamado <a href="https://pt.wikipedia.org/wiki/Tri%C3%A2ngulo_de_Sierpinski">Triângulo de Sierpinski</a>.
</p>

<p>
Usando a notação visual de Wolfram<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>, podemos expressá-la assim:
</p>


<div id="org388c3ed" class="figure">
<p><img src="img/rule90.png" alt="rule90.png" />
</p>
<p><span class="figure-number">Figura 3: </span>Visualização gráfica da Rule 90. Fonte: Wolfram (2002; adaptado).</p>
</div>

<p>
Na figura acima, células <i>pretas</i>  estão vivas, enquanto células <i>brancas</i>
estão mortas.
</p>

<p>
A regra é expressada como <i>oito</i> situações possíveis, condizentes com as
oito <i>vizinhanças</i> possíveis, para uma vizinhança de três células
(vizinho esquerdo, célula atual, e vizinho direito).
</p>

<p>
Em cada  situação, o estado  atual da vizinhança é  representado pelos
três quadrados de cima, e o estado  que a célula ao meio da vizinhança
assumirá  no  próximo passo  será  o  mesmo estado  representado  pelo
quadrado solitário, na segunda linha.
</p>

<p>
Por  exemplo, na  Rule 90,  caso uma  célula esteja  <i>viva</i> e  seus dois
vizinhos estejam também <i>vivos</i>, esta célula <i>morrerá</i> (veja o caso mais à
esquerda na Figura <a href="#org388c3ed">3</a>).
</p>

<p>
Podemos gerar um gráfico, onde cada  linha representa uma nova fita de
células, após  aplicarmos as regras  do autômato celular à  linha logo
acima da mesma.
</p>

<p>
Para uma linha  inicial com apenas uma célula viva  ao centro, teremos
um desenho similar a este:
</p>

<p>

</p>


<div id="org375977c" class="figure">
<p><img src="img/rule90_evol.png" alt="rule90_evol.png" />
</p>
<p><span class="figure-number">Figura 4: </span>Evolução da Rule 90 através do tempo. Fonte: Wolfram (2002; adaptado)</p>
</div>
</div>
</div>

<div id="outline-container-org3433e34" class="outline-3">
<h3 id="org3433e34">Construindo a Rule 90 em APL</h3>
<div class="outline-text-3" id="text-org3433e34">
<p>
Vamos  passo  a  passo  criar  uma expressão  em  APL  que  possa  ser
transformada  em  uma  função;  esta  função  deverá  tomar  um  vetor
arbitrário e binário qualquer, e retornar  um novo vetor com o <i>próximo
passo</i> do autômato celular Rule 90.
</p>

<p>
Primeiro, começamos com nosso vetor inicial.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Em seguida, criaremos um vetor  com dois elementos; cada elemento será
uma cópia de <code>r</code>.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     r r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>  <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Agora, faremos com que o primeiro vetor seja rotacionado uma casa para
a <b>direita</b>,  e que  o segundo  vetor seja rotacionado  uma casa  para a
<b>esquerda</b>.
</p>

<p>
Normalmente aplicaríamos  uma rotação  horizontal (<code>⌽</code>)  a cada  um, mas
podemos simplesmente distribuir rotações a <code>-1</code> e <code>1</code> para cada respectivo
vetor, através de <i>rotate each</i> (<code>⌽¨</code>). Veja:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     <span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;</span>r r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>  <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Agora, somaremos  ambos os  vetores, elemento a  elemento, de  forma a
criar um só, através de uma redução com somatório (<code>+/</code>):
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     <span style="color: #9d81ba;">+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;</span>r r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Vamos   fazer  uma   pausa  aqui   e  contemplar   o  que   temos  até
então, comparando <code>r</code> a esse resultado parcial:
</p>

<pre class="example" id="org916c0dd">
r       =&gt; 0 0 0 0 0 1 0 0 0 0 0
parcial =&gt; 0 0 0 0 1 0 1 0 0 0 0
</pre>

<p>
Se observarmos com bastante atenção, veremos que <code>parcial</code> nada mais é
que a quantidade de vizinhos vivos de cada célula respectiva de <code>r</code>.
</p>

<p>
Se experimentarmos  isso com um  novo vetor <code>z</code>,  com três números  <code>1</code> ao
centro, obteremos o seguinte:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      z<span style="color: #9d81ba;">&#8592;</span><span style="color: #0D9C94;">&#175;5</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>

      z            <span style="color: #454459;">&#9053; </span><span style="color: #454459;">Novo vetor z</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>

      <span style="color: #9d81ba;">+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;</span>z z <span style="color: #454459;">&#9053; </span><span style="color: #454459;">Vetor parcial</span>
 <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Mais explicitamente, compare:
</p>

<pre class="example" id="org177a60a">
z       =&gt; 0 0 0 0 0 1 1 1 0 0 0 0 0
parcial =&gt; 0 0 0 0 1 1 2 1 1 0 0 0 0
</pre>

<p>
Isto é algo muito bom. Uma vez que temos a contagem de vizinhos vivos
à  esquerda  e à  direita  de  uma  célula,  podemos tomar  um  atalho
interessante na Rule 90.
</p>

<p>
Observando a Figura <a href="#org388c3ed">3</a>,  podemos ver  que o estado  da célula
atual não  é verdadeiramente  importante para  esta regra.  Assim, não
precisamos  levar  em  consideração  a  célula  atual.
</p>

<p>
Também  não  precisamos levar  em  consideração  quais vizinhos  estão
vivos, pois a Rule 90 parece operar apenas com uma quantidade exata de
vizinhos vivos.
</p>

<p>
Assim,  temos uma  única frase  que resume  a Rule  90: <b>uma  célula só
permanecerá viva se tiver exatamente um vizinho vivo</b>.
</p>

<p>
Isto pode ser feito através de comparar cada um dos elementos do vetor
resultante com o número <code>1</code>, da seguinte forma:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">=+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;</span>r r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> 
</pre>
</div>

<p>
Em APL, toda  vez que realizamos uma comparação entre  um escalar e um
vetor,  o  vetor  é  implicitamente  percorrido,  e  cada  elemento  é
comparado  com o  escalar fornecido  (neste caso,  <code>1</code>). Como  resposta,
recebemos um  <i>novo vetor</i>, contendo  a resposta de cada  comparação. Em
APL,  <code>true</code>   e  <code>false</code>  estão   diretamente  relacionados  a  <code>1</code>   e  <code>0</code>,
respectivamente, portanto nosso novo vetor também é populado por <code>1</code>'s e
<code>0</code>'s.
</p>

<p>
Com isso, temos  nossa nova expressão que calcula o  próximo estado da
Rule 90 para uma fita circular. Veja que em nenhum momento mencionamos
o  <i>tamanho do  vetor</i>, portanto  a  expressão independe  do tamanho  do
mesmo.
</p>

<p>
Podemos melhorar um pouco nossa  expressão. O resultado, na verdade, é
um <i>vetor  encapsulado</i>, que podemos  desencapsular com uma  operação de
<i>disclose</i>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">&#8835;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">=+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;</span>r r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
E  também   podemos  evitar  a   repetição  do  vetor  <code>r</code>   através  do
encapsulamento  do  mesmo,  o  que  fará com  que  as  rotações  sejam
distribuídas para  quantas cópias de  <code>r</code> sejam necessárias,  através da
operação <i>enclose</i>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">&#8835;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">=+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;&#8834;</span>r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Tudo  o  que  resta  é   transformar  esta  expressão  em  uma  função
propriamente  dita.  Para tanto,  vamos  substituir  <code>r</code> pelo  parâmetro
formal <code>⍵</code>, e colocar a expressão  no escopo de uma expressão lambda, ou
seja, de uma função <i>inline</i>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog"><span style="color: #9d81ba;">{&#8835;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">=+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;&#8834;&#9077;}</span>
</pre>
</div>

<p>
Esta  expressão pode  então ser  atribuída a  um nome  qualquer. Neste
caso, chamaremos ela de <code>rule90</code>.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">rule90<span style="color: #9d81ba;">&#8592;{&#8835;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">=+/</span><span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;&#168;&#8834;&#9077;}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org57ddd18" class="outline-2">
<h2 id="org57ddd18">Generalizando as regras</h2>
<div class="outline-text-2" id="text-org57ddd18">
<p>
Há algum tempo atrás, criei algumas funções para generalizar a criação
de regras de autômatos celulares,  cujos estados sejam apenas <i>vivos</i> ou
<i>mortos</i>.
</p>

<p>
A expressão <code>findrule</code> a seguir&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-dyalog">findrule<span style="color: #9d81ba;">&#8592;{</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">+&#8835;+/((-&#9082;-(&#8970;&#9082;&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;&#9082;)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;&#9082;)&#215;&#168;&#8834;&#9077;}</span>
</pre>
</div>

<p>
..é uma função <i>diádica</i> (tomando dois  argumentos; um à esquerda e um à
direita). Seu primeiro argumento enumera  a quantidade de elementos na
vizinhança, sendo  sempre ímpar; seu  segundo argumento toma  um vetor
arbitrário de <code>0</code>'s e <code>1</code>'s.
</p>

<p>
Assim, se aplicarmos <code>findrule</code> a <code>3</code> e ao nosso vetor <code>r</code>
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #f5c791;">3</span> findrule r
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span>
</pre>
</div>

<p>
veremos que cada  um dos elementos se enquadra em  um caso de qualquer
regra arbitrária que  sirva para uma vizinhança de  três elementos; se
contarmos os casos da Figura <a href="#org388c3ed">3</a> da direita para a esquerda,
começando de <code>1</code>, teremos um paralelo com a Rule 90, por exemplo.
</p>

<p>
Explicarei melhor o  funcionamento de <code>findrule</code> <a href="#org7cce7c2">ao  final deste artigo</a>,
pois não é de entendimento trivial.
</p>

<p>
Para facilitar, podemos especificar  <code>findrule</code> apenas para situações de
uma  vizinhança   de  três   elementos.  O   operador  <i>jot</i>   (<code>∘</code>)  liga
permanentemente o valor  <code>3</code> a uma cópia da  função <code>findrule</code>, produzindo
uma  nova   função,  no   processo,  que   demande  apenas   um  único
parâmetro. Nomearemos esta função como <code>findrule3</code>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">findrule3<span style="color: #9d81ba;">&#8592;</span><span style="color: #f5c791;">3</span><span style="color: #9d81ba;">&#8728;</span>findrule
</pre>
</div>

<p>
Por fim, vamos especificar uma função  que toma apenas um vetor com os
números  das regras  onde  <i>a  célula permanece  viva</i>,  e substitui  os
números do resultado de <code>findrule3</code> por <code>1</code> ou <code>0</code>, dependendo da existência
do estado em questão no vetor informado a essa função.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">do_rule3<span style="color: #9d81ba;">&#8592;{(</span><span style="color: #0D9C94;">findrule3</span> <span style="color: #9d81ba;">&#9082;)&#9015;&#168;&#8834;&#9021;(&#9075;</span><span style="color: #f5c791;">8</span><span style="color: #9d81ba;">)&#8714;&#9077;}</span>
</pre>
</div>

<p>
Por exemplo, podemos emular a aplicação  de <code>rule90</code> em <code>r</code> através do uso
de <code>do_rule3</code> para os casos <code>2</code>, <code>4</code>, <code>5</code> e <code>7</code>, que são os números dos casos de
vizinhança para os quais a célula em questão sobrevive (vide a Figura <a href="#org388c3ed">3</a>):
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      rule90 r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>

      <span style="color: #0D9C94;">r</span> do_rule3 <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">7</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org55b163a" class="outline-2">
<h2 id="org55b163a">Criando mais regras de ACs</h2>
<div class="outline-text-2" id="text-org55b163a">
<p>
Com estas simples funções  podemos, finalmente, criar outros autômatos
celulares à base de simples  generalização. Vejamos como podemos criar
outras regras:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">rule30  <span style="color: #9d81ba;">&#8592;</span> <span style="color: #9d81ba;">{&#9077;</span> <span style="color: #0D9C94;">do_rule3</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">7</span><span style="color: #9d81ba;">}</span>       <span style="color: #454459;">&#9053; </span><span style="color: #454459;">Aleat&#243;rio</span>
rule110 <span style="color: #9d81ba;">&#8592;</span> <span style="color: #9d81ba;">{&#9077;</span> <span style="color: #0D9C94;">do_rule3</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">7</span><span style="color: #9d81ba;">}</span>     <span style="color: #454459;">&#9053; </span><span style="color: #454459;">Estruturas localizadas</span>
rule250 <span style="color: #9d81ba;">&#8592;</span> <span style="color: #9d81ba;">{&#9077;</span> <span style="color: #0D9C94;">do_rule3</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">7</span><span style="color: #9d81ba;">}</span>   <span style="color: #454459;">&#9053; </span><span style="color: #454459;">Repeti&#231;&#227;o</span>
rule254 <span style="color: #9d81ba;">&#8592;</span> <span style="color: #9d81ba;">{&#9077;</span> <span style="color: #0D9C94;">do_rule3</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">7</span><span style="color: #9d81ba;">}</span> <span style="color: #454459;">&#9053; </span><span style="color: #454459;">Repeti&#231;&#227;o</span>
</pre>
</div>

<p>
Segundo  Wolfram  (2002)  e  Mitchell, Hraber  e  Crutchfield  (1993),
autômatos  celulares podem  se classificar  de algumas  formas, quanto
mais  se aproximam  da ideia  de <i>caos</i>,  sendo estruturas  extremamente
recorrentes na natureza também.
</p>

<p>
Vamos  criar mais  algumas  funções  e estruturas  para  nos ajudar  a
visualizar estas classificações.
</p>
</div>
</div>

<div id="outline-container-org955c3c9" class="outline-2">
<h2 id="org955c3c9">Representação visual</h2>
<div class="outline-text-2" id="text-org955c3c9">
<p>
Começamos atribuindo  uma função  qualquer de  autômato celular  a uma
variável global <code>fn</code> em nosso  <i>workspace</i>. Poderemos trocar esta função à
medida que for necessário.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">fn<span style="color: #9d81ba;">&#8592;</span>rule90
</pre>
</div>

<p>
Finalmente, criarei uma função que gera  uma matriz de evolução de uma
fita de acordo com uma certa quantidade de gerações informada.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">genboard<span style="color: #9d81ba;">&#8592;{</span><span style="color: #0D9C94;">board</span><span style="color: #9d81ba;">&#8592;&#9082;&#8900;{(</span><span style="color: #0D9C94;">fn</span><span style="color: #9d81ba;">&#9059;&#9077;)</span><span style="color: #0D9C94;">board</span><span style="color: #9d81ba;">}&#168;(&#9077;</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">)&#9076;</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;&#9077;}</span>
</pre>
</div>

<p>
A matriz gerada é similar à Figura <a href="#org375977c">4</a>, porém numérica:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     r genboard <span style="color: #f5c791;">10</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span>
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span>
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span>
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Podemos abstrair isso mais um  pouco, trocando os <code>0</code>'s pelo caractere
de espaço e os <code>1</code>'s pelo caractere <code>o</code> minúsculo, através desta função:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">showboard<span style="color: #9d81ba;">&#8592;{{</span><span style="color: #f5c791;">' o'</span><span style="color: #9d81ba;">[</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">+&#9077;]}&#168;(&#9082;</span> <span style="color: #0D9C94;">genboard</span> <span style="color: #9d81ba;">&#9077;)}</span>
</pre>
</div>

<p>
O  resultado  é uma  representação  que  lembra  mais ainda  a  Figura
<a href="#org375977c">4</a>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     r showboard <span style="color: #f5c791;">10</span>
     o
    o o
   o   o
  o o o o
 o       o
o o     o o
o  o   o  o
ooo o o ooo
  o     o
 o o   o o

</pre>
</div>
</div>

<div id="outline-container-org3ab6ce8" class="outline-3">
<h3 id="org3ab6ce8">Representando outros autômatos visualmente</h3>
<div class="outline-text-3" id="text-org3ab6ce8">
<p>
Podemos  usar  nova representação  visual  para  testar nossos  outros
autômatos celulares.
</p>

<p>
Vamos  começar atribuindo  a <code>r</code>  um novo  vetor de  51 elementos,  onde
apenas a célula do meio está viva:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">r<span style="color: #9d81ba;">&#8592;</span><span style="color: #0D9C94;">&#175;25</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">50</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>
</pre>
</div>

<p>
A Rule 30  é conhecida por representar um AC  <i>aleatório</i>, ou seja, gera
estruturas  aleatórias em  seu desenvolvimento.  É, portanto,  uma boa
representação de comportamento <i>caótico</i>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">fn<span style="color: #9d81ba;">&#8592;</span>rule30  <span style="color: #9d81ba;">&#8900;</span> r showboard <span style="color: #f5c791;">20</span>
                    o
                   ooo
                  oo  o
                 oo oooo
                oo  o   o
               oo oooo ooo
              oo  o    o  o
             oo oooo  oooooo
            oo  o   ooo     o
           oo oooo oo  o   ooo
          oo  o    o oooo oo  o
         oo oooo  oo o    o oooo
        oo  o   ooo  oo  oo o   o
       oo oooo oo  ooo ooo  oo ooo
      oo  o    o ooo   o  ooo  o  o
     oo oooo  oo o  o ooooo  ooooooo
    oo  o   ooo  oooo o    ooo      o
   oo oooo oo  ooo    oo  oo  o    ooo
  oo  o    o ooo  o  oo ooo oooo  oo  o
 oo oooo  oo o  oooooo  o   o   ooo oooo

</pre>
</div>

<p>
A Rule  110 é  conhecida por  ser <i>Turing-completa</i>,  ou seja,  dada uma
entrada adequada, é capaz de simular uma Máquina de Turing.
</p>

<p>
Como sua evolução ocorre para a  "esquerda", criarei um novo vetor <i>ad
hoc</i> de 21 elementos, onde apenas o elemento mais à direita vale <code>1</code>.
</p>

<p>
A Rule  110, é,  portanto, um  sistema <i>à beira  do caos</i>,  onde podemos
ainda  observar   estruturas  localizadas  em  meio   a  comportamento
caótico.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">    fn<span style="color: #9d81ba;">&#8592;</span>rule110  <span style="color: #9d81ba;">&#8900;</span> <span style="color: #9d81ba;">(</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">20</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">))</span> showboard <span style="color: #f5c791;">20</span>
                   o
                  oo
                 ooo
                oo o
               ooooo
              oo   o
             ooo  oo
            oo o ooo
           ooooooo o
          oo     ooo
         ooo    oo o
        oo o   ooooo
       ooooo  oo   o
      oo   o ooo  oo
     ooo  oooo o ooo
    oo o oo  ooooo o
   oooooooo oo   ooo
  oo      oooo  oo o
 ooo     oo  o ooooo
oo o    ooo oooo   o
</pre>
</div>

<p>
As Rules 250 e 254 constituem-se de padrões de repetição mais simples,
e um pouco menos interessantes.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">fn<span style="color: #9d81ba;">&#8592;</span>rule250  <span style="color: #9d81ba;">&#8900;</span> r showboard <span style="color: #f5c791;">20</span>
                    o
                   o o
                  o o o
                 o o o o
                o o o o o
               o o o o o o
              o o o o o o o
             o o o o o o o o
            o o o o o o o o o
           o o o o o o o o o o
          o o o o o o o o o o o
         o o o o o o o o o o o o
        o o o o o o o o o o o o o
       o o o o o o o o o o o o o o
      o o o o o o o o o o o o o o o
     o o o o o o o o o o o o o o o o
    o o o o o o o o o o o o o o o o o
   o o o o o o o o o o o o o o o o o o
  o o o o o o o o o o o o o o o o o o o
 o o o o o o o o o o o o o o o o o o o o
</pre>
</div>

<div class="org-src-container">
<pre class="src src-dyalog">fn<span style="color: #9d81ba;">&#8592;</span>rule254  <span style="color: #9d81ba;">&#8900;</span> r showboard <span style="color: #f5c791;">20</span>
                    o
                   ooo
                  ooooo
                 ooooooo
                ooooooooo
               ooooooooooo
              ooooooooooooo
             ooooooooooooooo
            ooooooooooooooooo
           ooooooooooooooooooo
          ooooooooooooooooooooo
         ooooooooooooooooooooooo
        ooooooooooooooooooooooooo
       ooooooooooooooooooooooooooo
      ooooooooooooooooooooooooooooo
     ooooooooooooooooooooooooooooooo
    ooooooooooooooooooooooooooooooooo
   ooooooooooooooooooooooooooooooooooo
  ooooooooooooooooooooooooooooooooooooo
 ooooooooooooooooooooooooooooooooooooooo
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5f78737" class="outline-2">
<h2 id="org5f78737">Conclusão</h2>
<div class="outline-text-2" id="text-org5f78737">
<p>
Muito foi explorado  até aqui, no sentido dos padrões  e da informação
que  poderiam ser  criados. O  mais interessante  é que  este processo
quase não demandou linhas de código.
</p>

<p>
Na  minha apresentação,  mostrei formas  de codificar  a <code>rule90</code>,  como
feito anteriormente, usando  as mesmas ideias, porém em  Common Lisp e
em C++; foram  bem mais trabalhosas em termos de  quantidade de código
escrito,  mesmo operando  sobre suas  respectivas estruturas  de dados
mais acessíveis (listas e <code>std::vector</code>, respectivamente). Todavia, pude
transportar a  ideia por trás  do algoritmo para estas  linguagens sem
maiores problemas.
</p>

<p>
A lição que fica para o uso  de APL no contexto de autômatos celulares
é a de que, mesmo que uma  linguagem pareça não ser tão útil, acredito
que aprender tal  linguagem possa abrir as portas da  mente para novas
formas de desenvolver alguns algoritmos. Muitas vezes, por ter um foco
diferenciado,  uma  linguagem  pode   apresentar-nos  outra  forma  de
resolver  um  problema,  por  vezes  de  forma  mais  sucinta  para  o
programador.
</p>

<hr>
<p>
<a id="org7cce7c2"></a>
</p>
</div>
</div>

<div id="outline-container-orgb7e0bcd" class="outline-2">
<h2 id="orgb7e0bcd">Extra: Explicando <code>findrule</code></h2>
<div class="outline-text-2" id="text-orgb7e0bcd">
<p>
Mais acima, simplesmente mostrei esta função&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-dyalog">findrule<span style="color: #9d81ba;">&#8592;{</span><span style="color: #f5c791;">1</span><span style="color: #9d81ba;">+&#8835;+/((-&#9082;-(&#8970;&#9082;&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;&#9082;)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;&#9082;)&#215;&#168;&#8834;&#9077;}</span>
</pre>
</div>

<p>
&#x2026;e disse  que a explicaria  mais tarde,  justamente por não  ser tão
trivial e por  ser um pouco mais complexa. Tentarei  fazer isto agora,
mostrando passo-a-passo como construi-la, assim como fiz com <code>rule90</code>.
</p>

<p>
Devo dizer que esta seção é mais extensa. Como esta manipulação é um
pouco  mais   complicada,  não   medi  palavras  para   explicá-la.  O
interessante  do raciocínio  exposto  a seguir  é  que, muitas  vezes,
alguns recursos complexos chegam a  tornarem-se óbvios dado o poder de
manutenção vetorial da  linguagem, porém exige um pouco  mais de tempo
de explicação para que o leitor acostume-se ao raciocínio.
</p>
</div>

<div id="outline-container-org4c35159" class="outline-3">
<h3 id="org4c35159">Racionalizando a função</h3>
<div class="outline-text-3" id="text-org4c35159">
<p>
Primeiramente,  vamos falar  a  respeito  de como  a  função  em si  é
codificada, sem fazer nenhuma operação.
</p>

<p>
As  regras  de  autômatos  celulares são  constituídas  com  base  nas
vizinhanças e demonstram dados <i>binários</i>  a respeito do estado final da
célula. Se  tomarmos a Rule  90 e  a transcrevermos em  ASCII, teremos
algo assim:
</p>

<pre class="example" id="org8bafe55">
111 110 101 100 011 010 001 000
 0   1   0   1   1   0   1   0

 8   7   6   5   4   3   2   1
</pre>

<p>
Se observarmos a segunda linha, que diz respeito somente ao estado das
células para  cada caso  da regra, teremos  o número  binário <code>01011010</code>
que, não coincidentemente, equivale ao número <code>90</code> na base decimal.
</p>

<p>
A terceira  linha, mais abaixo, é  uma ordem imposta para  os casos em
questão, de forma que iniciemos a contagem da direita para a esquerda,
uma decisão a ser explicada logo a seguir.
</p>

<p>
A  ideia  de  <code>findrule</code>  é  que,  dada  uma  configuração  qualquer  de
vizinhança, dado o seu tamanho e  uma ordem da <b>direita</b> para a <b>esquerda</b>
(começando do número <code>1</code>), possamos identificar qual o número do <i>caso da
regra</i> ao qual aquela vizinhança se aplica.
</p>

<p>
Por exemplo, se tivermos uma fita contendo apenas <code>0 1 1</code> para uma
vizinhança de tamanho <code>3</code>, teremos como resultado os números <code>6 4 7</code>, pois
estas são as ordens equivalentes para os casos das vizinhanças <code>101</code> (da
primeira  célula),  <code>011</code>  (da  segunda   célula)  e  <code>110</code>  (da  terceira
célula). Lembre-se de que nossas <i>fitas</i> de células são circulares.
</p>

<p>
Assim, para a construção do  próximo estado do nosso autômato celular,
bastaria percorrer cada um dos elementos do  vetor <code>6 4 7</code>. O número ali
informado equivaleria à posição do novo estado de cada célula no vetor
de saídas para cada caso (a  segunda linha do quadro anterior, onde se
lê o número <code>90</code> em binário).
</p>

<p>
Isto  significa que  a  fita  circular <code>0  1  1</code>  transforma-se na  fita
circular <code>0 1 1</code> no próximo passo da  Rule 90, mas isto já não abrange a
operação de <code>findrule</code>, e sim utiliza seu resultado.
</p>
</div>
</div>

<div id="outline-container-org961dc7d" class="outline-3">
<h3 id="org961dc7d">Iniciando variáveis de apoio</h3>
<div class="outline-text-3" id="text-org961dc7d">
<p>
Vamos começar  definindo duas  variáveis: <code>a</code>, que  indica o  tamanho da
nossa vizinhança, e <code>r</code>, que será a nossa <i>fita</i> para testes.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">a<span style="color: #9d81ba;">&#8592;</span><span style="color: #f5c791;">3</span>
r<span style="color: #9d81ba;">&#8592;</span><span style="color: #0D9C94;">&#175;5</span><span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">,(</span><span style="color: #f5c791;">10</span><span style="color: #9d81ba;">&#9076;</span><span style="color: #f5c791;">0</span><span style="color: #9d81ba;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d92607" class="outline-3">
<h3 id="org7d92607">Vetor decrescente de múltiplos de <code>2</code></h3>
<div class="outline-text-3" id="text-org7d92607">
<p>
Primeiramente, geramos um vetor com números de <code>1</code> a <code>a</code>.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">&#9075;</span>a
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">3</span> 
</pre>
</div>

<p>
Em  seguida,  subtraimos  <code>1</code>  de  cada um  dos  elementos  deste  vetor
gerado. Isto equivale também  a somar <code>¯1</code> a cada um  dos valores, o que
fazemos  para   tomar  vantagem  do   fato  de  APL   ser  normalmente
interpretada da <i>direita</i> para a <i>esquerda</i>, no que tange à precedência de
funções e operadores.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> 
</pre>
</div>

<p>
Em seguida, tomaremos cada um destes números, e tornaremo-os expoentes
para o número <code>2</code>. Por exemplo, para cada número <code>x</code>, calcularemos \(2^x\) e
colocaremos em um novo vetor, no seu lugar.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">4</span>
</pre>
</div>

<p>
Finalmente, usaremos a forma <i>monádica</i>  da função de <i>rotação horizontal</i>
(<code>⌽</code>), que inverterá o vetor.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a
<span style="color: #f5c791;">4</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org427a66e" class="outline-3">
<h3 id="org427a66e">Explicação do vetor de múltiplos criado</h3>
<div class="outline-text-3" id="text-org427a66e">
<p>
Vamos parar por um momento para fazer um apanhado do que foi feito até
agora.
</p>

<p>
Esta  expressão  gera  um  vetor  decrescente  de  elementos  que  são
múltiplos de <code>2</code>. A quantidade de  múltiplos é dada pela variável <code>a</code>, que
estabelecemos previamente.
</p>

<p>
Como  cada  vizinhança pode  ser  compreendida  como sendo  um  número
binário com  uma quantidade <code>a</code>  de dígitos,  o que pretendemos  fazer é
transformar tal número de volta para a base decimal.
</p>

<p>
Por exemplo,  uma vizinhança  como <code>0 1 1</code>  pode ser  transformada para
números decimais através  da multiplicação de cada um  de seus dígitos
por um múltiplo de <code>2</code>, desta forma:
</p>

\begin{align*}
        011_{2} &= (0 \times 2^2) + (1 \times 2^1) + (0 \times 2^0)\\
        &= (0 \times 4) + (1 \times 2) + (1 \times 1)\\
        &= 3_{10}
\end{align*}

<p>
Veja  que,  para esta  vizinhança,  o  que  fazemos é  multiplicar  os
estados de:
</p>

<ul class="org-ul">
<li>O vizinho da esquerda por <code>4</code>;</li>
<li>A célula em questão por <code>2</code>;</li>
<li>O vizinho da direita por <code>1</code>.</li>
</ul>

<p>
E então, estes três resultados são somados.
</p>

<p>
Estes números de multiplicação  dizem respeito justamente à vizinhança
de  <i>três</i>  elementos  de  cada  uma das  células,  podendo  mudar  para
outros tipos de vizinhanças (por  exemplo, o próximo tamanho válido de
vizinhança seria  com cinco elementos).   Veja que o estado  da célula
atual sempre multiplica o valor do <i>meio</i> da vizinhança.
</p>

<p>
Sendo  assim, a  expressão  anterior  foi feita  para  gerar um  vetor
decrescente de múltiplos de 2,  que serão posteriormente utilizados em
vizinhanças para sua eventual transformação em um número decimal.
</p>
</div>
</div>

<div id="outline-container-org794fce3" class="outline-3">
<h3 id="org794fce3">Distribuindo multiplicativamente o vetor para cópias de <code>r</code></h3>
<div class="outline-text-3" id="text-org794fce3">
<p>
Continuando com nosso  código em APL, multiplicaremos,  agora, cada um
desses  números  por  uma  cópia   da  fita  original,  armazenada  em
<code>r</code>.  Podemos  fazer  isso  distribuindo   uma  cópia  de  <code>r</code>  para  cada
multiplicação necessária:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     <span style="color: #9d81ba;">(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a<span style="color: #9d81ba;">)&#215;&#168;&#8834;</span>r 
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>  <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>  <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Veja que esta operação gerou  três vetores subsequentes, onde todos os
números <code>1</code> foram transformados em um dos múltiplos de <code>r</code>.
</p>
</div>
</div>

<div id="outline-container-org0ecf517" class="outline-3">
<h3 id="org0ecf517">Rotacionando os vetores resultantes</h3>
<div class="outline-text-3" id="text-org0ecf517">
<p>
Agora, precisamos  dar um jeito de  fazer com que estes  vetores sejam
ligeiramente rotacionados para que cada valor passe a ficar exatamente
no local da célula da qual diz respeito.
</p>

<p>
Ou seja, o vetor de valores à esquerda será rotacionado uma vez para a
direita;  o vetor  de valores  à direita  será rotacionado  uma vez  à
esquerda, e o vetor de valores no local correto não será rotacionado.
</p>

<p>
Esse  deslocamento é  importante para  a  soma de  múltiplos do  nosso
cálculo anterior; ao realizarmos a soma destes vetores rotacionados, o
número na base dez representando a vizinhança para a célula em questão
poderá  ser obtido  através da  soma elemento-a-elemento  de todos  os
vetores.
</p>

<p>
Por exemplo,  um número <code>4</code>,  como já vimos,  diz respeito à  célula que
está imediatamente  à <i>direita</i> de si. Portanto, precisamos rotacioná-lo
<code>-1</code> casas, efetivamente levando o número <code>4</code> a direita.
</p>

<p>
Já um número <code>1</code> diz respeito à célula imediatamente à <i>esquerda</i> de si.
Portanto, rotacionamos o último vetor <code>1</code> casa, efetivamente levando o
número <code>1</code> à esquerda.
</p>

<p>
O motivo para isso é que, se somarmos finalmente os vetores elemento a
elemento,  teremos  o  número  representado  pela  vizinhança  daquela
célula. Assim, estaremos tratando três vizinhanças de apenas uma vez.
</p>

<p>
Vejamos um exemplo visual. Se tivéssemos uma vizinhança como <code>0 1 0</code>
 e multiplicássemos suas cópias por <code>4</code>,  <code>2</code> e <code>1</code>, teríamos os respectivos
 vetores:
</p>

<pre class="example" id="orgf8f41d8">
0 4 0
0 2 0
0 1 0
</pre>

<p>
Agora, podemos locomover o primeiro vetor  uma casa para a frente, e o
último vetor uma casa  para trás. Como o vetor do  meio diz respeito à
célula em questão, ele poderá ficar onde está:
</p>

<pre class="example" id="orgf3bc13b">
0 0 4   ⍝ Movido para a direita
0 2 0
1 0 0   ⍝ Movido para a esquerda
</pre>

<p>
Se somarmos estes vetores elemento-a-elemento, teremos:
</p>

<pre class="example" id="orgcbd90f4">
1 2 4
</pre>

<p>
Se  analisarmos  adequadamente,  poderemos   ver  que  as  respectivas
vizinhanças   das  células   cujos   lugares   estes  números   ocupam
correspondem, exatamente, a tais números:
</p>

<pre class="example" id="orgcc36d12">
0 0 1 =&gt; 1
0 1 0 =&gt; 2
1 0 0 =&gt; 4
</pre>

<p>
Para tanto, seria suficiente criar um vetor de índices de rotação como
<code>¯1 0 1</code>, similar  ao que foi anteriormente usado em  <code>rule90</code>, e usar uma
rotação horizontal distribuída (<code>⌽¨</code>) sobre estes  múltiplos já gerados.
</p>

<p>
Todavia,  veja que  este  vetor não  pode ter  este  tamanho fixo;  se
tivéssemos  trabalhando com  uma  vizinhança de  cinco elementos,  por
exemplo, precisaríamos de um vetor como <code>¯2 ¯1 0 1 2</code>.
</p>

<p>
Assim, precisamos, primeiro, de uma expressão  em função de <code>a</code> que crie
este vetor.
</p>
</div>
</div>

<div id="outline-container-orge92faa8" class="outline-3">
<h3 id="orge92faa8">Criando vetor de índices de rotação</h3>
<div class="outline-text-3" id="text-orge92faa8">
<p>
Começaremos criando um novo vetor com os números de <code>1</code> a <code>a</code> inclusive.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">&#9075;</span>a                                                      
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">3</span>
</pre>
</div>

<p>
Precisamos  calcular o  número "do  meio" deste  vetor, que  deverá se
transformar em zero.  Sabemos para nosso experimento que <code>a</code>  vale <code>3</code>; se
dividíssemos <code>a</code> por <code>2</code>, teríamos  um valor quebrado (como esperado, pois
<code>a</code> é sempre ímpar):
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span>                                                      
<span style="color: #f5c791;">1</span><span style="color: #9d81ba;">.</span><span style="color: #f5c791;">5</span>
</pre>
</div>

<p>
Se tomarmos o <i>chão</i> (<i>floor</i>) desse valor e subtrairmos este resultado de
<code>a</code>, teremos um número que poderia  ser subtraído de cada um dos números
do  vetor anterior,  de forma  a criarmos  nosso vetor  de índices  de
rotação.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">)</span> 
<span style="color: #f5c791;">2</span>
</pre>
</div>

<p>
Veja que isto <i>garante</i> a lógica  envolvida: se subtrairmos <code>2</code> do vetor&#x2026;
</p>

<pre class="example" id="org0ae0359">
1 2 3
</pre>

<p>
&#x2026;teremos&#x2026;
</p>

<pre class="example" id="org740fe64">
¯1 0 1
</pre>

<p>
Para  facilitar  a  escrita  em  APL, vamos  inverter  o  sinal  deste
resultado, e então somá-lo ao vetor. Não é a única forma de fazer esta
operação, mas é o suficiente por enquanto.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">-</span>a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">)</span>
<span style="color: #0D9C94;">&#175;2</span>

      <span style="color: #9d81ba;">(-</span>a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;</span>a
<span style="color: #0D9C94;">&#175;1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org063a98c" class="outline-3">
<h3 id="org063a98c">Distribuindo as rotações para os vetores criados</h3>
<div class="outline-text-3" id="text-org063a98c">
<p>
O próximo passo  é juntar ambas as expressões,  realizando uma rotação
horizontal distribuída (ou <i>rotate each</i>, <code>⌽¨</code>)  entre cada um dos vetores de
múltiplos de <code>2</code> e os índices gerados.
</p>

<p>
Colocaremos  a  expressão  dos   índices  entre  parênteses,  e  então
aplicaremos a  rotação para  a outra expressão.  Os parênteses  só são
necessários  para  a expressão  dos  índices,  por  ela estar  mais  à
esquerda.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">     <span style="color: #9d81ba;">((-</span>a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;</span>a<span style="color: #9d81ba;">)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a<span style="color: #9d81ba;">)&#215;&#168;&#8834;</span>r 
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>  <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>  <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Finalmente, somaremos  todos os vetores criados,  elemento a elemento,
através de uma redução por soma (ou <i>reduce sum</i>, <code>+/</code>).
</p>

<p>
O  vetor  resultante  estará  <i>encapsulado</i>  devido  à  distribuição  de
multiplicações  de <code>r</code>.  Portanto,  precisaremos  desencapsulá-lo com  a
operação <i>disclose</i> (<code>⊃</code>).
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #9d81ba;">+/((-</span>a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;</span>a<span style="color: #9d81ba;">)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a<span style="color: #9d81ba;">)&#215;&#168;&#8834;</span>r
 <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">7</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>

      <span style="color: #9d81ba;">&#8835;+/((-</span>a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;</span>a<span style="color: #9d81ba;">)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a<span style="color: #9d81ba;">)&#215;&#168;&#8834;</span>r 
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">7</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Isto é quase o suficiente, à  exceção de um último detalhe: APL começa
a contar seus elementos a partir do  índice <code>1</code>, e não do índice <code>0</code>. Este
vetor resultante é  <i>zero-based</i>, portanto precisamos somar <code>1</code>  a cada um
destes elementos.
</p>

<p>
Para tanto,  basta somar  um escalar  <code>1</code> no  início desta  expressão; o
escalar será automaticamente distribuído para cada um dos elementos do
vetor.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      <span style="color: #f5c791;">1</span><span style="color: #9d81ba;">+&#8835;+/((-</span>a<span style="color: #9d81ba;">-(&#8970;</span>a<span style="color: #9d81ba;">&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;</span>a<span style="color: #9d81ba;">)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;</span>a<span style="color: #9d81ba;">)&#215;&#168;&#8834;</span>r 
<span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">2</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">8</span> <span style="color: #f5c791;">7</span> <span style="color: #f5c791;">5</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org94e17b6" class="outline-3">
<h3 id="org94e17b6">Finalizando</h3>
<div class="outline-text-3" id="text-org94e17b6">
<p>
Finalmente, esta  é a expressão que  calcula o <i>caso</i> para  cada uma das
células  de um  vetor,  para  qualquer regra  de  um autômato  celular
unidimensional  arbitrário,  dado um  tamanho  ímpar  qualquer para  a
vizinhança (variável  <code>a</code>) e o já  citado vetor de células  qualquer com
estados binários (variável <code>r</code>).
</p>

<p>
Substituiremos <code>a</code> e <code>r</code> pelos  parâmetros formais <code>⍺</code> e <code>⍵</code>, respectivamente,
que  simbolizam  o   parâmetro  passado  à  função à   esquerda  e  à
direita, e também colocaremos a expressão em chaves, para que torne-se
uma expressão lambda. Vejamos seu uso <i>ad hoc</i>:
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      a <span style="color: #9d81ba;">{&#8835;+/((-&#9082;-(&#8970;&#9082;&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;&#9082;)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;&#9082;)&#215;&#168;&#8834;&#9077;}</span> r 
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">7</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>

<p>
Podemos  dar a  essa expressão  lambda o  nome <code>findrule</code>,  e finalmente
poderemos utilizá-la de forma mais sucinta.
</p>

<div class="org-src-container">
<pre class="src src-dyalog">      findrule<span style="color: #9d81ba;">&#8592;{&#8835;+/((-&#9082;-(&#8970;&#9082;&#247;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">))+&#9075;&#9082;)&#9021;&#168;(&#9021;</span><span style="color: #f5c791;">2</span><span style="color: #9d81ba;">*</span><span style="color: #0D9C94;">&#175;1</span><span style="color: #9d81ba;">+&#9075;&#9082;)&#215;&#168;&#8834;&#9077;}</span>

      a findrule r
<span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">1</span> <span style="color: #f5c791;">3</span> <span style="color: #f5c791;">7</span> <span style="color: #f5c791;">6</span> <span style="color: #f5c791;">4</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span> <span style="color: #f5c791;">0</span>
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Notas de Rodap&eacute;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
"Cellular   automata  (CA)  are   discrete  spatially-extended
dynamical  systems that  have been  studied extensively  as models  of
physical  processes   and  as  computational  devices".   Retirado  de
Mitchell, M., Hraber,  P. &amp; Crutchfield, J. P. &#x2013;  <i>Revisiting the edge
of chaos</i>: Evolving Cellular  Automata to Perform Computations. Revista
<i>Complex Systems</i>, número 7, páginas 89 a 130, ano 1993.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Adaptado de Wolfram, S. A New Kind of Science, ano 2002. 
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<h3><a href="../">De volta à página anterior</a></h3>
</div>
</body>
</html>
