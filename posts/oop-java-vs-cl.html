<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt_BR" xml:lang="pt_BR">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Orientação a Objetos: Java /versus/ Common Lisp</title>
<meta name="author" content="Lucas Vieira" />
<meta name="description" content="Programming, Tech, and occasional rant space by Lucas Vieira" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-22RF3F5XE0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-22RF3F5XE0');
</script>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link id="theme-css" rel="stylesheet" type="text/css" href="../css/dark-theme.css" />
<link rel="icon" type="image/jpg" href="../img/cat-i-mage.jpg" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:image" content="../img/cat-i-mage.jpg">
<meta name="theme-color" content="#14171e">
</head>
<body>
<div id="preamble" class="status">
<nav><h1><a href="../">The Alchemist's Hideout</a></h1></nav><h1 class="title">Orientação a Objetos: Java <i>versus</i> Common Lisp</h1><p><i>Escrito em Jan 08, 2019 por Lucas Vieira<br/><a href="mailto:lucasvieira@lisp.com.br">lucasvieira@lisp.com.br</a></i></p>
</div>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc8711bd">Introdução</a>
<ul>
<li><a href="#org54ac93e">História da concepção da <i>orientação a objetos</i></a></li>
<li><a href="#org1d63e7f">O que será feito?</a>
<ul>
<li><a href="#orgbc979bc">ACHTUNG!</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7c2d20f">OO do "jeito Java"</a>
<ul>
<li><a href="#org3e0b9c2">Inicialização</a></li>
<li><a href="#org495684c">Interface para as formas</a></li>
<li><a href="#orgaeec673">Implementação das formas</a>
<ul>
<li><a href="#org0f9eecc">Círculo</a></li>
<li><a href="#org3c5c17c">Quadrado</a></li>
<li><a href="#org510a045">Pentágono</a></li>
</ul>
</li>
<li><a href="#orgd26aa81">Utilitários</a></li>
<li><a href="#org1525a49">Ponto de entrada do programa</a></li>
</ul>
</li>
<li><a href="#org3059b01">OO do "jeito Common Lisp"</a>
<ul>
<li><a href="#orgd8a6d54">Inicialização</a></li>
<li><a href="#org07c26b4">Operações genéricas</a></li>
<li><a href="#orge3d1b96">Classes</a></li>
<li><a href="#orgb4cec59">Métodos</a>
<ul>
<li><a href="#org2ea344a">Perímetro</a></li>
<li><a href="#org06cf9db">Área</a></li>
<li><a href="#org1ea5061">Quadrado do lado</a></li>
</ul>
</li>
<li><a href="#org7d8ab83">Utilitários</a>
<ul>
<li><a href="#org50a54ef">Soma dos quadrados dos lados</a></li>
</ul>
</li>
<li><a href="#org6f27485">Função principal para testes</a></li>
</ul>
</li>
<li><a href="#org974af07">Conclusão</a>
<ul>
<li><a href="#orga678f86">Comparação</a></li>
<li><a href="#orge3153eb"><i>Tangling</i> dos arquivos</a></li>
<li><a href="#orgfd4bbb2">Licenciamento</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc8711bd" class="outline-2">
<h2 id="orgc8711bd">Introdução</h2>
<div class="outline-text-2" id="text-orgc8711bd">
<p>
Este é mais um post envolvendo programação literada no meu blog &#x2013; desta vez, em
Português mesmo.
</p>

<p>
Neste texto, pretendo falar a respeito de <i>programação orientada a objetos</i>,
apresentando um paralelo entre a forma como este paradigma foi adotado pela
indústria e a forma como foi originalmente concebido por Alan Kay<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<div class="NOTES" id="org0ed41b7">
<p>
<b>NOTA:</b> Este post foi escrito para meu blog utilizando <code>org-mode</code> no Emacs, o que
 possibilita a extração do código, na ordem apresentada, e salvamento do mesmo
 em seus respectivos arquivos das linguagens aqui utilizadas. Veja a conclusão
 para visualizar o arquivo <code>.org</code> da postagem, e para exportar os arquivos de
 código para arquivos externos.
</p>

</div>
</div>
<div id="outline-container-org54ac93e" class="outline-3">
<h3 id="org54ac93e">História da concepção da <i>orientação a objetos</i></h3>
<div class="outline-text-3" id="text-org54ac93e">
<p>
Segundo Alan Kay, o paradigma de orientação a objetos foi inspirado pela antiga
linguagem <i>Simula</i>, que realizava certas operações (definidas por procedimentos)
sobre estruturas de dados. Kay via <i>Simula</i> como algo que parecia querer chegar a
algo, mas ainda não sabia descrever o que era.
</p>

<p>
O conceito de orientação a objetos, como originalmente concebido, tinha como
base uma organização hierárquica originalmente vista na biologia. Poderia-se
compreender que organismos, em especial células, comportavam-se como estruturas
com comportamento interno complexo, porém opaco ao resto do sistema; o contato
da célula com o mundo exterior a ela e vice-versa era feito através de um <i>canal</i>,
que poderia ser compreendido como uma membrana externa, que filtra certas
<i>mensagens</i> e decide como as responde, e se responde-as.
</p>

<p>
Ainda tomando este modelo de estrutura opaca com um canal de comunicação externo
por mensagens, percebeu-se que, quando aplicado um contexto matemático a esta
ideia, poderia surgir uma álgebra própria onde estas estruturas poderiam ser
manipuladas, de forma que esta troca de mensagens poderia ser descrita.
</p>

<p>
Às estruturas opacas, Alan Kay deu o nome de <i>objetos</i>, e estes foram os pilares
que o fizeram começar a trabalhar na linguagem Smalltalk. Para Kay, este
conceito de <i>objetos</i> não significaria apenas estruturas em uma linguagem, mas
também formas de representar estruturas reais e criar meios de comunicação
abstrata (por exemplo, entre computadores em uma rede). A influência de
Smalltalk chegou à comunidade de (Common) Lisp e, eventualmente, surgiu o CLOS
(<i>Common Lisp Object System</i>).
</p>

<p>
Estes conceitos influenciaram na criação da linguagem C++ e de outras linguagens
que, por sua vez, possibilitaram a implementação da orientação a objetos na
indústria de hoje, o que incluiu o advento da linguagem Java. Nestas linguagens,
o principal foco está na organização de objetos como uma evolução de estruturas
de dados, contendo, internamente, campos de dados e métodos que este objeto
poderia executar, seja alterando seu próprio estado interno, seja comunicando-se
com outros objetos do contexto.
</p>

<p>
A orientação a objetos estabelecida na indústria e ensinada nas universidades
normalmente lembra a forma como classifica-se em C++ e Java, e acabou
tornando-se um assunto controverso entre os puristas e estudiosos do assunto.
</p>
</div>
</div>
<div id="outline-container-org1d63e7f" class="outline-3">
<h3 id="org1d63e7f">O que será feito?</h3>
<div class="outline-text-3" id="text-org1d63e7f">
<p>
Neste post, pretendo mostrar implementações em Java e Common Lisp,
respectivamente, como representantes de dois modos de pensar a respeito de
orientação a objetos: Java como sendo uma vertente mais associada a C++, e
Common Lisp como uma vertente mais associada a Smalltalk. Tentaremos resolver o
seguinte problema, que é extremamente simples:
</p>

<blockquote>
<p>
Temos um certo conjunto de <i>formas</i>. Estas formas podem ser <i>círculos</i>, <i>quadrados</i> ou
<i>pentágonos</i>, todos sendo formas regulares. Cada uma das formas têm suas
peculiaridades necessárias para a sua construção, como <i>raio</i> ou <i>tamanho do
lado</i>. Gere um conjunto arbitrário de <i>formas</i>, e mostre as somas de seus
perímetros, as somas de suas áreas, e as somas do quadrado da medida do lado de
cada forma, caso seja possível.
</p>
</blockquote>
</div>
<div id="outline-container-orgbc979bc" class="outline-4">
<h4 id="orgbc979bc">ACHTUNG!</h4>
<div class="outline-text-4" id="text-orgbc979bc">
<p>
O objetivo deste exercício não é destacar uma linguagem ou uma visão do
paradigma como melhor que o outro, mas sim demonstrar a diferença no raciocínio
e na produção das soluções para o problema em questão. Evidenciam-se os
contrastes semânticos, acima dos sintáticos, ainda que não sejam completamente
dissociáveis.
</p>

<p>
Obviamente, possuo minhas próprias preferências com relação às linguagens
utilizadas, mas aqui pretendo apresentar uma espécie de pedra de roseta, e
deixar que o leitor tome suas próprias conclusões com relação às visões e formas
de resolução apresentadas.
</p>

<p>
Também não há a pretensão, aqui, de gerar código com excelência de performance,
sendo o entendimento do leitor o alvo mais importante. Todavia, como Common Lisp
pode ser uma linguagem muito ortodoxa, algumas seções incluem explicações extras
acerca da aparelhagem sintática da mesma. Recomendo abusar dos <i>links</i> entre o
texto e notas de rodapé, e vice-versa.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7c2d20f" class="outline-2">
<h2 id="org7c2d20f">OO do "jeito Java"</h2>
<div class="outline-text-2" id="text-org7c2d20f">
<p>
O "jeito Java" consiste na declaração de uma abstração-mor, e então
na criação de sub-abstrações, para a resolução do problema.
</p>

<p>
Temos uma abstração que determina as operações básicas de uma forma: uma
<i>interface</i>. As formas em si são abstraídas por <i>classes</i> que implementam esta
interface.
</p>

<p>
Criamos um contêiner capaz de armazenar instâncias de classes que implementem a
interface declarada, e então poderemos iterar sobre este contêiner, para então
calcular as três operações requisitadas pelo enunciado.
</p>
</div>
<div id="outline-container-org3e0b9c2" class="outline-3">
<h3 id="org3e0b9c2">Inicialização</h3>
<div class="outline-text-3" id="text-org3e0b9c2">
<p>
Um programa Java é inicializado com a declaração do pacote que conterá as
estruturas a serem utilizadas. Logo em seguida, importamos outros pacotes (ou
classes específicas em certos pacotes) que auxiliarão na implementação do nosso
programa.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">package</span> <span style="color: #0D9C94;">OOPTest</span>;

<span style="color: #9d81ba;">import</span> <span style="color: #0D9C94;">java</span>.<span style="color: #0D9C94;">util</span>.<span style="color: #62D2DB;">ArrayList</span>;
<span style="color: #9d81ba;">import</span> <span style="color: #0D9C94;">java</span>.<span style="color: #0D9C94;">lang</span>.<span style="color: #62D2DB;">UnsupportedOperationException</span>;
<span style="color: #9d81ba;">import</span> <span style="color: #0D9C94;">java</span>.<span style="color: #0D9C94;">lang</span>.<span style="color: #62D2DB;">Math</span>;
</pre>
</div>

<div class="NOTES" id="orgd223dc1">
<p>
<b>NOTA:</b> Nenhuma das estruturas a seguir será declarada com acesso público, uma vez
que o objetivo do programa é criar uma aplicação auto-contida e simples, não um
projeto formal. Esta decisão torna desnecessário declarar estas estruturas em
seus próprios arquivos.
</p>

</div>
</div>
</div>
<div id="outline-container-org495684c" class="outline-3">
<h3 id="org495684c">Interface para as formas</h3>
<div class="outline-text-3" id="text-org495684c">
<p>
Implementamos uma interface chamada <code>IShape</code>, que descreve valores básicos, que
podem ser obtidos proceduralmente para uma forma qualquer: <i>perímetro</i>, <i>área</i> e
<i>quadrado do lado</i>.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">interface</span> <span style="color: #62D2DB;">IShape</span> {
    <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">perimeter</span>();
    <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">area</span>();
    <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">squaredSide</span>();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgaeec673" class="outline-3">
<h3 id="orgaeec673">Implementação das formas</h3>
<div class="outline-text-3" id="text-orgaeec673">
<p>
Uma vez declarada a interface a ser implementada por cada forma, podemos
declarar as classes para as formas em si.
</p>
</div>
<div id="outline-container-org0f9eecc" class="outline-4">
<h4 id="org0f9eecc">Círculo</h4>
<div class="outline-text-4" id="text-org0f9eecc">
<p>
A classe <code>Circle</code> implementa a forma de um círculo. Como atributos próprios da
classe, temos um valor decimal especificando o raio do círculo, chamado <code>radius</code>,
e também temos um construtor para a classe, que explicita a necessidade de um
valor para o raio, ao criarmos uma instância da mesma<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">class</span> <span style="color: #62D2DB;">Circle</span> <span style="color: #9d81ba;">implements</span> <span style="color: #62D2DB;">IShape</span> {
    <span style="color: #9d81ba;">private</span> <span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">radius</span>;

    <span style="color: #9d81ba;">public</span> <span style="color: #0bc9cf;">Circle</span>(<span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">radius</span>) {
        <span style="color: #9d81ba;">this</span>.radius = radius;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">perimeter</span>() {
        <span style="color: #9d81ba;">return</span> <span style="color: #f5c791;">2</span>.<span style="color: #f5c791;">0f</span> * (<span style="color: #62D2DB;">float</span>)<span style="color: #0D9C94;">Math</span>.PI * <span style="color: #9d81ba;">this</span>.radius;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">area</span>() {
        <span style="color: #9d81ba;">return</span> (<span style="color: #62D2DB;">float</span>)<span style="color: #0D9C94;">Math</span>.PI * <span style="color: #9d81ba;">this</span>.radius * <span style="color: #9d81ba;">this</span>.radius;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">squaredSide</span>() {
        <span style="color: #9d81ba;">throw</span> <span style="color: #9d81ba;">new</span> <span style="color: #62D2DB;">UnsupportedOperationException</span>(<span style="color: #f5c791;">"A circle has no sides"</span>);
    }
}
</pre>
</div>

<p>
Note que, como estamos tratando de um círculo, não possuímos valor para seu
lado. Poderíamos tratar o lado como sendo o comprimento da circunferência do
mesmo, mas este seria seu perímetro; ao invés disso, vamos assumir que esta
operação é impossível, uma vez que um círculo, tecnicamente, não possui lados.
</p>

<div class="NOTES" id="org663506b">
<p>
<b>NOTA:</b> Veja que o método que implementa o quadrado do lado de um círculo levanta
 uma exceção do tipo <code>UnsupportedOperationException</code>, com uma mensagem específica
 de erro. Esta exceção é uma forma de mostrar que a operação não é suportada por
 esta classe. Fazemos isto porque <code>Circle</code> implementa a interface <code>IShape</code>, que
 obriga nossas classes a implementarem <i>todas</i> as operações da interface.
</p>

</div>
</div>
</div>
<div id="outline-container-org3c5c17c" class="outline-4">
<h4 id="org3c5c17c">Quadrado</h4>
<div class="outline-text-4" id="text-org3c5c17c">
<p>
O quadrado é, provavelmente, a classe de mais simples implementação: todas as
suas operações são triviais, e o quadrado do seu lado é idêntico à sua área.
</p>

<p>
Internamente, armazenamos o tamanho de seu lado, e explicitamos, no construtor,
a necessidade do fornecimento deste valor para que possamos instanciar
adequadamente a classe.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">class</span> <span style="color: #62D2DB;">Square</span> <span style="color: #9d81ba;">implements</span> <span style="color: #62D2DB;">IShape</span> {
    <span style="color: #9d81ba;">private</span> <span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">side</span>;

    <span style="color: #9d81ba;">public</span> <span style="color: #0bc9cf;">Square</span>(<span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">side</span>) {
        <span style="color: #9d81ba;">this</span>.side = side;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">perimeter</span>() { 
        <span style="color: #9d81ba;">return</span> <span style="color: #f5c791;">4</span>.<span style="color: #f5c791;">0f</span> * <span style="color: #9d81ba;">this</span>.side;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">area</span>() { 
        <span style="color: #9d81ba;">return</span> <span style="color: #9d81ba;">this</span>.side * <span style="color: #9d81ba;">this</span>.side;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">squaredSide</span>() { 
        <span style="color: #9d81ba;">return</span> <span style="color: #9d81ba;">this</span>.side * <span style="color: #9d81ba;">this</span>.side;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org510a045" class="outline-4">
<h4 id="org510a045">Pentágono</h4>
<div class="outline-text-4" id="text-org510a045">
<p>
O pentágono possui as mesmas características do quadrado com relação ao seu
construtor, seu perímetro, e o quadrado do seu lado. Mas o cálculo da área do
pentágono é um pouco diferente.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">class</span> <span style="color: #62D2DB;">Pentagon</span> <span style="color: #9d81ba;">implements</span> <span style="color: #62D2DB;">IShape</span> {
    <span style="color: #9d81ba;">private</span> <span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">side</span>;

    <span style="color: #9d81ba;">public</span> <span style="color: #0bc9cf;">Pentagon</span>(<span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">side</span>) {
        <span style="color: #9d81ba;">this</span>.side = side;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">perimeter</span>() { 
        <span style="color: #9d81ba;">return</span> <span style="color: #f5c791;">5</span>.<span style="color: #f5c791;">0f</span> * <span style="color: #9d81ba;">this</span>.side;
    }

    <span style="color: #9d81ba;">private</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">apothem</span>() {
        <span style="color: #9d81ba;">return</span> (<span style="color: #9d81ba;">this</span>.side / <span style="color: #f5c791;">2</span>.<span style="color: #f5c791;">0f</span>) / (<span style="color: #62D2DB;">float</span>)Math.tan(Math.toRadians(<span style="color: #f5c791;">36</span>.<span style="color: #f5c791;">0f</span>));
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">area</span>() { 
        <span style="color: #9d81ba;">return</span> (<span style="color: #9d81ba;">this</span>.apothem() * <span style="color: #9d81ba;">this</span>.perimeter()) / <span style="color: #f5c791;">2</span>.<span style="color: #f5c791;">0f</span>;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">squaredSide</span>() { 
        <span style="color: #9d81ba;">return</span> <span style="color: #9d81ba;">this</span>.side * <span style="color: #9d81ba;">this</span>.side;
    }
}
</pre>
</div>

<p>
Como você pode perceber, temos um método a mais, com acesso <i>privado</i>, que calcula
o comprimento do <i>apótema</i><sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> do pentágono. Baseado neste método, que só pode
ser acessado internamente pela classe, podemos calcular a área do pentágono,
baseada no comprimento do apótema e no seu perímetro.
</p>
</div>
</div>
</div>
<div id="outline-container-orgd26aa81" class="outline-3">
<h3 id="orgd26aa81">Utilitários</h3>
<div class="outline-text-3" id="text-orgd26aa81">
<p>
A geração de uma quantidade arbitrária de formas e o cálculo das operações (soma
dos perímetros, soma das áreas, soma dos quadrados dos lados) são encapsulados
como métodos estáticos de uma classe <code>Utility</code>, para melhor
compartimentalização. A implementação destas operações é bem evidente, com
exceção da implementação da soma dos quadrados dos lados.
</p>

<p>
As formas em questão são armazenadas em um <code>ArrayList</code>, que será então repassado
aos métodos de cálculo em questão.
</p>

<p>
Outra informação relevante é que, pelo fato de estes métodos serem estáticos,
não é necessário instanciarmos esta classe para utilizá-los. Uma chamada
conveniente a <code>Utility.nomeDoMetodo(...)</code> é o suficiente para seus usos.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">class</span> <span style="color: #62D2DB;">Utility</span> {
    <span style="color: #9d81ba;">public</span> <span style="color: #9d81ba;">static</span> <span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt; <span style="color: #0bc9cf;">makeShapes</span>(<span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">numShapes</span>) {
        <span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt; <span style="color: #7CF083;">arr</span> = <span style="color: #9d81ba;">new</span> <span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt;();
        <span style="color: #9d81ba;">for</span>(<span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">i</span> = <span style="color: #f5c791;">1</span>; i &lt;= (<span style="color: #62D2DB;">int</span>)(numShapes / <span style="color: #f5c791;">3</span>); i++) {
            arr.add(<span style="color: #9d81ba;">new</span> <span style="color: #62D2DB;">Circle</span>(i));
            arr.add(<span style="color: #9d81ba;">new</span> <span style="color: #62D2DB;">Square</span>(i));
            arr.add(<span style="color: #9d81ba;">new</span> <span style="color: #62D2DB;">Pentagon</span>(i));
        }
        <span style="color: #9d81ba;">return</span> arr;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #9d81ba;">static</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">sumOfPerimeters</span>(<span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt; <span style="color: #7CF083;">arr</span>) {
        <span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">sum</span> = <span style="color: #f5c791;">0</span>.<span style="color: #f5c791;">0f</span>;
        <span style="color: #9d81ba;">for</span>(<span style="color: #62D2DB;">IShape</span> <span style="color: #7CF083;">s</span> : arr) {
            sum += s.perimeter();
        }
        <span style="color: #9d81ba;">return</span> sum;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #9d81ba;">static</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">sumOfAreas</span>(<span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt; <span style="color: #7CF083;">arr</span>) {
        <span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">sum</span> = <span style="color: #f5c791;">0</span>.<span style="color: #f5c791;">0f</span>;
        <span style="color: #9d81ba;">for</span>(<span style="color: #62D2DB;">IShape</span> <span style="color: #7CF083;">s</span> : arr) {
            sum += s.area();
        }
        <span style="color: #9d81ba;">return</span> sum;
    }

    <span style="color: #9d81ba;">public</span> <span style="color: #9d81ba;">static</span> <span style="color: #62D2DB;">float</span> <span style="color: #0bc9cf;">sumOfSquaredSides</span>(<span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt; <span style="color: #7CF083;">arr</span>) {
        <span style="color: #62D2DB;">float</span> <span style="color: #7CF083;">sum</span> = <span style="color: #f5c791;">0</span>.<span style="color: #f5c791;">0f</span>;
        <span style="color: #9d81ba;">for</span>(<span style="color: #62D2DB;">IShape</span> <span style="color: #7CF083;">s</span> : arr) {
            <span style="color: #9d81ba;">try</span> {
                sum += s.squaredSide();
            } <span style="color: #9d81ba;">catch</span>(<span style="color: #62D2DB;">UnsupportedOperationException</span> <span style="color: #7CF083;">e</span>) {
                <span style="color: #454459;">/* </span><span style="color: #454459;">...</span><span style="color: #454459;"> */</span>
            }
        }
        <span style="color: #9d81ba;">return</span> sum;
    }
}
</pre>
</div>

<p>
Para a operação da soma dos quadrados dos lados, iteramos sobre o nosso
contêiner de formas. Porém, se a forma atual em questão for um círculo, sabemos
que este levantará uma exceção de <code>UnsupportedOperationException</code>. Para evitar que
isto signifique a interrupção do nosso programa, encapsulamos a tentativa de
contabilização do quadrado do lado da forma atual em um bloco <code>try-catch</code>. Este
bloco <i>trata a exceção</i>, executando o bloco <code>catch</code> caso ela seja levantada.
</p>

<p>
Neste exemplo, caso a exceção em questão seja levantada, a contabilização do
quadrado do lado para a forma atual será apenas ignorada.
</p>
</div>
</div>
<div id="outline-container-org1525a49" class="outline-3">
<h3 id="org1525a49">Ponto de entrada do programa</h3>
<div class="outline-text-3" id="text-org1525a49">
<p>
Enfim, podemos executar nosso programa. Para tanto, precisamos de mais uma
classe, que aqui chamamos <code>Program</code>, com um método estático chamado <code>main</code>. Aqui,
criamos dez formas, e então imprimimos cada uma das operações, baseadas no
conjunto de dez formas que criamos arbitrariamente.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9d81ba;">class</span> <span style="color: #62D2DB;">Program</span> {
    <span style="color: #9d81ba;">public</span> <span style="color: #9d81ba;">static</span> <span style="color: #62D2DB;">void</span> <span style="color: #0bc9cf;">main</span>(<span style="color: #62D2DB;">String</span>[] <span style="color: #7CF083;">args</span>) {
        <span style="color: #62D2DB;">ArrayList</span>&lt;<span style="color: #62D2DB;">IShape</span>&gt; <span style="color: #7CF083;">shapes</span> = Utility.makeShapes(<span style="color: #f5c791;">10</span>);
        System.out.println(<span style="color: #f5c791;">"Sum of Perimeters: "</span>
                + Utility.sumOfPerimeters(shapes));
        System.out.println(<span style="color: #f5c791;">"Sum of Areas: "</span> + Utility.sumOfAreas(shapes));
        System.out.println(<span style="color: #f5c791;">"Sum of Squared Sides: "</span>
                + Utility.sumOfSquaredSides(shapes));
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3059b01" class="outline-2">
<h2 id="org3059b01">OO do "jeito Common Lisp"</h2>
<div class="outline-text-2" id="text-org3059b01">
<p>
O "jeito Common Lisp" consiste no uso da forma "original" de orientação a
objetos, mencionada anteriormente.
</p>

<p>
Esta forma de orientação a objetos lembra o funcionamento de Smalltalk, e é
tratada, por alguns autores, como uma boa interpretação da orientação a objetos,
ao ser implementada em uma linguagem de programação<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>.
</p>

<p>
O <i>Common Lisp Object System</i> foi criado muito depois da concepção da linguagem
Lisp original, sendo originalmente uma extensão de Common Lisp, que
posteriormente viria a ser incluída na especificação da linguagem<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>.
</p>
</div>
<div id="outline-container-orgd8a6d54" class="outline-3">
<h3 id="orgd8a6d54">Inicialização</h3>
<div class="outline-text-3" id="text-orgd8a6d54">
<p>
Primeiramente, vamos iniciar nosso projeto através da criação de um pacote em
Common Lisp. Aqui estarei utilizando, também, o <i>system</i> <code>iterate</code>, que substitui o
uso do macro <code>loop</code> na linguagem<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span>ql:quickload <span style="color: #9d81ba;">:iterate</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defpackage</span> <span style="color: #62D2DB;">:oop-test</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">:use</span> <span style="color: #454459;">#:</span><span style="color: #d7af87;">cl</span> <span style="color: #454459;">#:</span><span style="color: #d7af87;">iterate</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<p>
Common Lisp exige que exportemos certos símbolos, caso precisemos utilizá-los em
outros pacotes. O <i>environment</i> de Common Lisp é inicializado no "pacote" <code>cl-user</code>
(ou <code>common-lisp-user</code>). Como este é apenas um teste de propósito geral, podemos
adentrar o pacote e definir símbolos logo dentro dele.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">in-package</span> <span style="color: #9d81ba;">:oop-test</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<div class="NOTES" id="org2260485">
<p>
<b>NOTA:</b> Caso você já possua o arquivo de código deste programa e esteja
simplesmente tentando revisitar o que foi feito neste pacote, basta executar a
linha acima no seu REPL, após dar <code>(load "arquivo.lisp")</code>. Não entrarei aqui em
pormenores da modularização de Common Lisp, por acreditar que isto seria melhor
endereçado em um post sobre Quicklisp, Quickproject, ASDF, <i>systems</i> e <i>packages</i>,
que posso vir a fazer no futuro.
</p>

</div>
</div>
</div>
<div id="outline-container-org07c26b4" class="outline-3">
<h3 id="org07c26b4">Operações genéricas</h3>
<div class="outline-text-3" id="text-org07c26b4">
<p>
Baseado no que foi dito na introdução, precisamos de um vocabulário inicial
de mensagens que podemos passar para alguns objetos, como uma espécie de lista
de comandos gerais.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defgeneric</span> <span style="color: #0bc9cf;">perimeter</span> <span style="color: #47ba99;">(</span>shape<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">:documentation</span> <span style="color: #d7af87;">"Calculates perimeter of a shape."</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defgeneric</span> <span style="color: #0bc9cf;">area</span> <span style="color: #47ba99;">(</span>shape<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">:documentation</span> <span style="color: #d7af87;">"Calculates area of a shape."</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defgeneric</span> <span style="color: #0bc9cf;">squared-side</span> <span style="color: #47ba99;">(</span>shape<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">:documentation</span> <span style="color: #d7af87;">"Squares the side value of a regular shape."</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<p>
Aproveitamos, também, para utilizar o suporte da linguagem a <i>docstrings</i> para
criar documentação mínima para nossas operações genéricas. Isto poderia ser
útil, caso esquecêssemos do que cada uma destas mensagens poderia requisitar.
</p>

<p>
Perceba que o uso do átomo <code>shape</code> como aparente argumento destas operações
genéricas é completamente arbitrário, apesar de possuir carga semântica para o
programador. Em outras palavras, Common Lisp não possui exigência sobre a
natureza dos símbolos utilizados em argumentos de <i>generics</i>; eles só estão lá
para "marcar lugares" de argumentos em métodos &#x2013; isto será entendido logo mais.
</p>
</div>
</div>
<div id="outline-container-orge3d1b96" class="outline-3">
<h3 id="orge3d1b96">Classes</h3>
<div class="outline-text-3" id="text-orge3d1b96">
<p>
Em CLOS, classes são definidas a partir de duas coisas: uma lista de
superclasses das quais derivam, e uma lista de <i>slots</i>, cada qual com suas
propriedades. Aqui não teremos nenhuma superclasse para derivar, mas temos três
classes, cada qual com um slot relevante.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defclass</span> <span style="color: #62D2DB;">circle</span> <span style="color: #47ba99;">()</span>
  <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>%radius <span style="color: #9d81ba;">:initarg</span> <span style="color: #9d81ba;">:radius</span>
            <span style="color: #9d81ba;">:reader</span> radius<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defclass</span> <span style="color: #62D2DB;">square</span> <span style="color: #47ba99;">()</span>
  <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>%side <span style="color: #9d81ba;">:initarg</span> <span style="color: #9d81ba;">:side</span>
          <span style="color: #9d81ba;">:reader</span> side<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defclass</span> <span style="color: #62D2DB;">pentagon</span> <span style="color: #47ba99;">()</span>
  <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>%side <span style="color: #9d81ba;">:initarg</span> <span style="color: #9d81ba;">:side</span>
          <span style="color: #9d81ba;">:reader</span> side<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<p>
A classe <code>circle</code> define nosso círculo. Temos um <i>slot</i> chamado <code>%radius</code>, que
armazenará o raio do nosso círculo.
</p>

<p>
O mesmo vale para o <i>slot</i> <code>%side</code> de <code>square</code> e <code>pentagon</code>, que representa o tamanho do
lado destas formas.
</p>

<p>
Veja que definimos duas propriedades extras para cada <i>slot</i>. A primeira é o
<code>initarg</code>; a segunda, um <code>reader</code>. O <code>initarg</code> representa o átomo que simboliza a
chave para definir o valor para aquele <i>slot</i>, durante o instanciamento da
classe<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>.
</p>

<p>
Já o <code>reader</code> é a definição rápida de uma forma de realizar a leitura daquele
<i>slot</i>, em outros cantos do código. Ele será necessário para que possamos,
efetivamente, recuperar os dados da instância. No caso de <code>circle</code>, o raio
de um círculo poderá ser recuperado de uma instância com <code>(radius
instancia)</code>. Situações similares ocorrerão para os lados de <code>square</code> e
<code>pentagon</code><sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>.
</p>
</div>
</div>
<div id="outline-container-orgb4cec59" class="outline-3">
<h3 id="orgb4cec59">Métodos</h3>
<div class="outline-text-3" id="text-orgb4cec59">
<p>
<i>Métodos</i>, em Common Lisp, nada mais são que especificações das <i>operações
genéricas</i>.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup> Ao definirmos o método, normalmente teremos um ou mais
parâmetros na lista de parâmetros que determinam a forma como a operação será
despachada, de acordo com o objeto passado por parâmetro.
</p>

<p>
Por exemplo, um argumento de assinatura <code>(variavel nome-da-classe)</code> implica que
aquele método possui implementação para a classe <code>nome-da-classe</code> e, portanto,
<code>variavel</code> terá uma mensagem a retornar mediante a invocação do método em
questão<sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>.
</p>

<p>
Realizaremos a implementação dos métodos por mensagem, ao invés de
implementarmos todos os métodos para cada classe, por vez.
</p>
</div>
<div id="outline-container-org2ea344a" class="outline-4">
<h4 id="org2ea344a">Perímetro</h4>
<div class="outline-text-4" id="text-org2ea344a">
<p>
A implementação das operações de perímetro são simples. A passagem da mensagem
<code>perimeter</code> para cada uma das instâncias das três classes realizará o despacho
para o método relativo ao tipo da classe.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">perimeter</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s circle<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* <span style="color: #f5c791;">2</span> pi <span style="color: #62D2DB;">(</span>radius s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>


<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">perimeter</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s square<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* <span style="color: #f5c791;">4</span> <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>


<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">perimeter</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s pentagon<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* <span style="color: #f5c791;">5</span> <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org06cf9db" class="outline-4">
<h4 id="org06cf9db">Área</h4>
<div class="outline-text-4" id="text-org06cf9db">
<p>
O cálculo da área para um círculo e um quadrado também não é diferente, nem
envolve complexidade extra alguma.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">area</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s circle<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* pi <span style="color: #62D2DB;">(</span>radius s<span style="color: #62D2DB;">)</span> <span style="color: #62D2DB;">(</span>radius s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>


<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">area</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s square<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span> <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<p>
Todavia, sabemos que teremos complexidade extra ao calcular a área de um
pentágono. Vamos nos preparar para isto, definindo um <i>macro</i><sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup> que converte
um ângulo em graus para radianos.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmacro</span> <span style="color: #0bc9cf;">deg-&gt;rad</span> <span style="color: #47ba99;">(</span>angle-in-degrees<span style="color: #47ba99;">)</span>
  `<span style="color: #47ba99;">(</span>/ <span style="color: #62D2DB;">(</span>* ,angle-in-degrees pi<span style="color: #62D2DB;">)</span> <span style="color: #f5c791;">180</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<p>
Podemos, agora, definir a forma de se calcular a área de um pentágono. Começamos
definindo uma função aninhada ao método<sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>, que calcula o
apótema. Utilizando esta função aninhada, e baseando-nos no cálculo do apótema e
do perímetro do pentágono, calculamos a área.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">area</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s pentagon<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">labels</span> <span style="color: #62D2DB;">(</span><span style="color: #9d81ba;">(</span>apothem <span style="color: #35BF88;">(</span>s<span style="color: #35BF88;">)</span>
             <span style="color: #35BF88;">(</span>/ <span style="color: #687184;">(</span>/ <span style="color: #d7af87;">(</span>side s<span style="color: #d7af87;">)</span> <span style="color: #f5c791;">2</span><span style="color: #687184;">)</span>
                <span style="color: #687184;">(</span>tan <span style="color: #d7af87;">(</span>deg-&gt;rad <span style="color: #f5c791;">36</span><span style="color: #d7af87;">)</span><span style="color: #687184;">)</span><span style="color: #35BF88;">)</span><span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
    <span style="color: #62D2DB;">(</span>/ <span style="color: #9d81ba;">(</span>* <span style="color: #35BF88;">(</span>apothem s<span style="color: #35BF88;">)</span>
          <span style="color: #35BF88;">(</span>perimeter s<span style="color: #35BF88;">)</span><span style="color: #9d81ba;">)</span>
       <span style="color: #f5c791;">2</span><span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1ea5061" class="outline-4">
<h4 id="org1ea5061">Quadrado do lado</h4>
<div class="outline-text-4" id="text-org1ea5061">
<p>
Aqui, definimos o cálculo do quadrado dos lados para o quadrado e para o
pentágono. <b>Note que, no caso do círculo, simplesmente não definimos o método</b>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">squared-side</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s square<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span> <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>


<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defmethod</span> <span style="color: #0bc9cf;">squared-side</span> <span style="color: #47ba99;">(</span><span style="color: #62D2DB;">(</span>s pentagon<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>* <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span> <span style="color: #62D2DB;">(</span>side s<span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7d8ab83" class="outline-3">
<h3 id="org7d8ab83">Utilitários</h3>
<div class="outline-text-3" id="text-org7d8ab83">
<p>
Da mesma forma como fizemos no "jeito" anterior, definiremos alguns
procedimentos como utilitários, tanto para gerar nosso contêiner de instâncias
como para gerar nossas operações.
</p>

<p>
As instâncias, seja lá quais forem, serão armazenadas em uma lista. O <i>form</i>
<code>collect</code>, no <i>macro</i> <code>iter</code>, garante que cada uma das instâncias geradas sejam
incorporadas ao fim da lista. Enquanto isso, <code>make-instance</code> demonstra como
podemos instanciar uma classe qualquer (veja a utilização das chaves previamente
definidas nos <code>:initarg</code> dos <i>slots</i> de cada classe).
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defun</span> <span style="color: #0bc9cf;">make-shapes</span> <span style="color: #47ba99;">(</span>num-shapes<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>iter <span style="color: #62D2DB;">(</span>for x from <span style="color: #f5c791;">1</span> to <span style="color: #9d81ba;">(</span>/ num-shapes <span style="color: #f5c791;">3</span><span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
        <span style="color: #62D2DB;">(</span>collect <span style="color: #9d81ba;">(</span>make-instance 'circle   <span style="color: #9d81ba;">:radius</span> x<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
        <span style="color: #62D2DB;">(</span>collect <span style="color: #9d81ba;">(</span>make-instance 'square   <span style="color: #9d81ba;">:side</span> x<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
        <span style="color: #62D2DB;">(</span>collect <span style="color: #9d81ba;">(</span>make-instance 'pentagon <span style="color: #9d81ba;">:side</span> x<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defun</span> <span style="color: #0bc9cf;">sum-of-perimeters</span> <span style="color: #47ba99;">(</span>list<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>iter <span style="color: #62D2DB;">(</span>for elt in list<span style="color: #62D2DB;">)</span>
        <span style="color: #62D2DB;">(</span>sum <span style="color: #9d81ba;">(</span>perimeter elt<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>

<span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defun</span> <span style="color: #0bc9cf;">sum-of-areas</span> <span style="color: #47ba99;">(</span>list<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>iter <span style="color: #62D2DB;">(</span>for elt in list<span style="color: #62D2DB;">)</span>
        <span style="color: #62D2DB;">(</span>sum <span style="color: #9d81ba;">(</span>area elt<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>
</div>
<div id="outline-container-org50a54ef" class="outline-4">
<h4 id="org50a54ef">Soma dos quadrados dos lados</h4>
<div class="outline-text-4" id="text-org50a54ef">
<p>
Temos um pequeno problema ao calcularmos as somas dos quadrados dos lados:
alguns de nossos objetos (mais especificamente, aqueles que sejam instâncias de
<code>circle</code>) não implementam o método <code>squared-side</code>. Como proceder?
</p>

<p>
Há diversas formas de fazer isto. Podemos implementar um método a ser chamado
para toda e qualquer mensagem enviada a <code>circle,</code> que não tenha uma resposta
definida; mas não abordaremos isto aqui. Outra forma seria <i>tratar a condição
sinalizada</i> quando o método não está implementado para o objeto<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>.
</p>

<p>
Mas faremos isto de forma ainda mais simples, para manter o código mais sucinto.
</p>

<p>
Lembra-se da definição da nossa operação genérica <code>squared-side</code>? Pois bem, Common
Lisp é uma linguagem que permite a reescrita e a recompilação de certos "blocos"
de código, mesmo enquanto o programa continua sendo executado. Podemos tanto
escrever uma nova definição para <code>squared-side</code> quanto editar diretamente a
definição inicial e recompilá-la, caso estivéssemos utilizando uma IDE de Common
Lisp.
</p>

<p>
Nesta nova definição da operação genérica, temos um <i>form</i> extra ao fim,
começado com <code>:method</code>, que define a <b>implementação padrão</b> do método para quaisquer
classes que não possuam implementação para ele. Como queremos que círculos
passem a não influenciar na soma, podemos criar, neste <i>form</i>, um método que
simplesmente retorna o valor <code>0</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defgeneric</span> <span style="color: #0bc9cf;">squared-side</span> <span style="color: #47ba99;">(</span>shape<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">:documentation</span> <span style="color: #d7af87;">"Squares the side value of a regular shape."</span><span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">:method</span> <span style="color: #62D2DB;">(</span>obj<span style="color: #62D2DB;">)</span> <span style="color: #f5c791;">0</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>

<p>
Depois disso, basta implementar a função de soma dos quadrados dos lados, como
se absolutamente nenhuma inconsistência pudesse acontecer antes.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defun</span> <span style="color: #0bc9cf;">sum-of-squared-sides</span> <span style="color: #47ba99;">(</span>list<span style="color: #47ba99;">)</span>
  <span style="color: #47ba99;">(</span>iter <span style="color: #62D2DB;">(</span>for elt in list<span style="color: #62D2DB;">)</span>
        <span style="color: #62D2DB;">(</span>sum <span style="color: #9d81ba;">(</span>squared-side elt<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6f27485" class="outline-3">
<h3 id="org6f27485">Função principal para testes</h3>
<div class="outline-text-3" id="text-org6f27485">
<p>
Definamos uma função qualquer, incumbida de gerar nossa sequência de dez formas,
e então imprimir os resultados das operações na tela. O uso do nome <code>main</code> aqui é
arbitrário, podendo ser substituído por qualquer outra coisa.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #0D9C94;">(</span><span style="color: #9d81ba;">defun</span> <span style="color: #0bc9cf;">main</span> <span style="color: #47ba99;">()</span>
  <span style="color: #47ba99;">(</span><span style="color: #9d81ba;">let</span> <span style="color: #62D2DB;">(</span><span style="color: #9d81ba;">(</span>shapes <span style="color: #35BF88;">(</span>make-shapes <span style="color: #f5c791;">10</span><span style="color: #35BF88;">)</span><span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
    <span style="color: #62D2DB;">(</span>format t <span style="color: #f5c791;">"Sum of Perimeters: ~a~%"</span>
            <span style="color: #9d81ba;">(</span>sum-of-perimeters shapes<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
    <span style="color: #62D2DB;">(</span>format t <span style="color: #f5c791;">"Sum of Areas: ~a~%"</span> <span style="color: #9d81ba;">(</span>sum-of-areas shapes<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span>
    <span style="color: #62D2DB;">(</span>format t <span style="color: #f5c791;">"Sum of Squared Sides: ~a~%"</span>
            <span style="color: #9d81ba;">(</span>sum-of-squared-sides shapes<span style="color: #9d81ba;">)</span><span style="color: #62D2DB;">)</span><span style="color: #47ba99;">)</span><span style="color: #0D9C94;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org974af07" class="outline-2">
<h2 id="org974af07">Conclusão</h2>
<div class="outline-text-2" id="text-org974af07">
<p>
Chegamos ao fim de ambas as implementações do mesmo problema. Possuimos duas
formas de resolução, sob o que outrora seria o mesmo paradigma, porém estas duas
formas mostraram-se bem diferentes.
</p>
</div>
<div id="outline-container-orga678f86" class="outline-3">
<h3 id="orga678f86">Comparação</h3>
<div class="outline-text-3" id="text-orga678f86">
<p>
Podemos montar um pequeno quadro, destacando as partes mais relevantes das
implementações e estabelecendo um paralelo entre elas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><i>Feature</i></th>
<th scope="col" class="org-left">Java</th>
<th scope="col" class="org-left">Common Lisp</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Abrangência da OO</td>
<td class="org-left">Obrigatória</td>
<td class="org-left">Suportada</td>
</tr>

<tr>
<td class="org-left">Dados internos do objeto</td>
<td class="org-left">Campos privados</td>
<td class="org-left"><i>Slots</i></td>
</tr>

<tr>
<td class="org-left">Modelagem genérica</td>
<td class="org-left">Interface</td>
<td class="org-left"><i>Generics</i></td>
</tr>

<tr>
<td class="org-left">Implementação do modelo genérico</td>
<td class="org-left">Total</td>
<td class="org-left">Parcial</td>
</tr>

<tr>
<td class="org-left">Localização dos métodos</td>
<td class="org-left">Na definição da classe</td>
<td class="org-left">No pacote ou no <i>top level</i></td>
</tr>

<tr>
<td class="org-left">Abstração mental do método</td>
<td class="org-left">Ação relacionada ao objeto</td>
<td class="org-left">Mensagem passada ao objeto</td>
</tr>
</tbody>
</table>

<p>
Neste momento, peço que pause e pondere a respeito do que apresentei neste
artigo. Veja se meu paralelo parece fazer sentido, se você notou mais alguma
diferença (ou se não notou diferença alguma).
</p>

<p>
Independente do conceito visto como melhor por você, leitor, lembre-se de que
situações específicas exigem ferramentas específicas.
</p>
</div>
</div>
<div id="outline-container-orge3153eb" class="outline-3">
<h3 id="orge3153eb"><i>Tangling</i> dos arquivos</h3>
<div class="outline-text-3" id="text-orge3153eb">
<p>
Como este artigo foi escrito no Emacs, em <code>org-mode</code>, você poderá obter o código
do mesmo a seguir. Os arquivos das linguagens Java e Common Lisp,
contendo o código-fonte em si, poderão ser obtidos ao colocar-se o
cursor sobre o bloco de código a seguir, e utilizando o atalho <code>C-c C-c</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #0D9C94;">(</span>org-babel-tangle<span style="color: #0D9C94;">)</span>
</pre>
</div>

<a href="./oop-java-vs-cl.org">Clique aqui para ir para o código-fonte.</a>
</div>
</div>
<div id="outline-container-orgfd4bbb2" class="outline-3">
<h3 id="orgfd4bbb2">Licenciamento</h3>
<div class="outline-text-3" id="text-orgfd4bbb2">
<p>
Todo e qualquer código descrito aqui é disponibilizado sob a licença BSD
2-Clause. Para mais informação, veja <a href="https://opensource.org/licenses/BSD-2-Clause">este link.</a>
</p>

<p>
Copyright (c) 2019, Lucas Vieira.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Notas de Rodap&eacute;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Boa parte do que levo em consideração como sendo "orientação a objetos
como originalmente concebida" foi o que vi Alan Kay explicando, em pessoa, na
sua <a href="https://www.youtube.com/watch?v=oKg1hTOQXoY">palestra na OOPSLA 1997</a>. Minha descrição é compacta, então uma melhor
compreensão dos aspectos e do contexto podem ser vistos na palestra em si.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Um círculo pode ser definido, matematicamente, como uma coordenada no
plano, e o tamanho do seu raio. Como não lidaremos com a posição do círculo em
nenhuma das hipóteses apresentadas, só precisamos obrigar o programador a
fornecer o raio do círculo. Este conceito de mínimo de atributos necessários
acaba se estendendo também ao quadrado e ao pentágono regulares que, aqui, são
determinados pelos tamanhos de seus lados.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Para mais informações: <a href="https://pt.wikihow.com/Descobrir-a-%C3%81rea-de-um-Pent%C3%A1gono">wikiHow - Como Descobrir a Área de um Pentágono</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Vide o livro <a href="https://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744">The Art of the Metaobject Protocol</a>. Infelizmente ainda não
tive a oportunidade de lê-lo, mas Alan Kay sugere que este livro é uma boa
literatura para a compreensão de como a orientação a objetos deveria ser
implementada.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Para saber mais sobre CLOS, você pode ler, de graça, os capítulos
relevantes do livro Practical Common Lisp, <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">aqui</a> e <a href="http://www.gigamonkeys.com/book/object-reorientation-classes.html">aqui</a>. Ademais, recomendo a
<a href="http://www.gigamonkeys.com/book/">leitura completa do livro</a> para maiores informações sobre a linguagem.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
O motivo para esta substituição é puramente arbitrário; ando
experimentando com o uso de um vocabulário mais "líspico", ao invés do formato
com átomos aparentemente soltos que o macro <code>loop</code> disponibiliza, por mera questão
de corretude, mas isto é desnecessário. Para mais informações acerca disso, veja
<a href="https://dspace.mit.edu/bitstream/handle/1721.1/41498/AI_WP_324.pdf">este paper</a>, de Jonathan Amsterdan (também disponível <a href="https://common-lisp.net/project/iterate/doc/Don_0027t-Loop-Iterate.html">em HTML</a>).
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
A real forma de utilização destas chaves será vista na seção de
Utilitários, mais adiante.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Um <code>:reader</code> de um <i>slot</i> define apenas uma forma de recuperação dos dados,
dada uma instância qualquer da classe. Para que o valor seja alterado, é
necessário definir um <code>:writer</code>. Por exemplo, caso o <code>:writer</code> para o raio do
círculo fosse chamado <code>radius</code>, poderíamos redefinir o raio com <code>(setf (radius
instancia) valor)</code>. Adicionalmente, quando o <code>:reader</code> e o <code>:writer</code> têm o mesmo
nome, podemos simplesmente definir o que chamamos de <code>:accessor</code>. Se <code>radius</code> fosse
o <code>:accessor</code> do raio, poderíamos tanto recuperar o raio com <code>(radius instancia)</code>
quanto redefinir o raio com <code>(setf (radius instancia) valor)</code>. Isto evita a
necessidade da utilização de funções de acesso a um <i>slot</i> de uma classe, e também
evita a necessidade de definir genéricos e métodos para tal.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Na verdade, é possível definirmos métodos, sem a necessidade de
especificar as operações genéricas para eles (neste caso, o compilador criará as
operações genéricas automaticamente). Todavia, é boa prática ter genéricos
especificados previamente, da mesma forma como um <i>overview</i> do conteúdo de um
arquivo em <code>C/C++</code> é melhor identificado pelos protótipos nos cabeçalhos (arquivos
<code>.h</code>, <code>.hpp</code>, <code>.hxx</code>, etc).
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Podemos ter métodos que são despachados de acordo com os tipos de um ou
mais argumentos, ou seja, mais de um argumento pode ter o nome de sua classe
especificado na implementação do método. Isto é mais útil que realizar
verificações por tipos de classes para certos argumentos.
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Em Lisp, <i>macros</i> são estruturas capazes de gerar partes de código em
tempo de compilação, efetivamente sendo as estrelas da metaprogramação na
linguagem, juntamente com a chamada homoiconicidade. Contudo, dialetos de Lisp
são famosos por tornar a definição de <i>macros</i> uma tarefa extremamente simples,
além de encorajada &#x2013; desde que, como qualquer outra <i>feature</i> de uma linguagem,
não haja abusos em seu uso.
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Em Common Lisp, funções aninhadas são definidas através dos "blocos"
<code>flet</code> e <code>labels</code> (este último é capaz de definir funções aninhadas recursivas),
sendo as funções definidas sob estes blocos válidas até o final do "bloco" em
si. O equivalente em comportamento para <i>macros</i> é o <code>macrolet</code>.
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Enquanto algumas linguagens orientadas a objetos possuem o conceito de
exceções que são sinalizadas quando uma situação ocorre &#x2013; exceções estas que,
quando não-tratadas, interrompem imediatamente a execução do programa &#x2013;, Common
Lisp possui a ideia de <i>conditions</i>, que suportam a intervenção direta do
programador no REPL ou na IDE, quando não são tratadas. O tratamento de uma
exceção normalmente ocorre através da utilização de blocos <code>try-catch</code>, enquanto
<i>conditions</i> possuem <code>handlers</code>, que podem também estar associados à chamada
automática de <code>restarts,</code> sejam eles definidos ou não pelo programador. Mais sobre
isto poderá ser visto no <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">capitulo relevante</a> do Practical Common Lisp.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<h3><a href="../">De volta à página anterior</a></h3>
</div>
</body>
</html>
