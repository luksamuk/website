<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt_BR" xml:lang="pt_BR">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Desenvolvimento em C no /Plan 9 From Bell Labs/</title>
<meta name="author" content="Lucas Vieira" />
<meta name="description" content="Programming, Tech, and occasional rant space by Lucas Vieira" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-22RF3F5XE0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-22RF3F5XE0');
</script>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link id="theme-css" rel="stylesheet" type="text/css" href="../css/dark-theme.css" />
<link rel="icon" type="image/jpg" href="../img/cat-i-mage.jpg" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:image" content="../img/cat-i-mage.jpg">
<meta name="theme-color" content="#14171e">
</head>
<body>
<div id="preamble" class="status">
<nav><h1><a href="../">The Alchemist's Hideout</a></h1></nav><h1 class="title">Desenvolvimento em C no <i>Plan 9 From Bell Labs</i></h1><p><i>Escrito em Mar 24, 2019 por Lucas Vieira<br/><a href="mailto:lucasvieira@lisp.com.br">lucasvieira@lisp.com.br</a></i></p>
</div>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9e9c7c9">Introdução</a>
<ul>
<li><a href="#orge91da29">O que é Plan 9?</a></li>
<li><a href="#org22a352c">Forks do Plan 9</a></li>
<li><a href="#orgc8e370c">Uso e escolha do 9front</a></li>
</ul>
</li>
<li><a href="#orgfae7b4e">Ferramentas de desenvolvimento</a>
<ul>
<li><a href="#orga0c2e65">Desenvolvimento no Linux</a></li>
<li><a href="#org6a10b0d">Desenvolvimento no <i>9front</i></a></li>
</ul>
</li>
<li><a href="#orgaeed476">Estrutura do projeto</a>
<ul>
<li><a href="#orgf5ca64d">Arquivos</a></li>
<li><a href="#org3c830f1">Método de compilação</a>
<ul>
<li><a href="#orgbc29063"><code>make</code></a></li>
<li><a href="#org97bd00a"><code>mk</code></a></li>
</ul>
</li>
<li><a href="#org39ede08">Controle de versão e manutenção de patches do sistema</a></li>
</ul>
</li>
<li><a href="#org268f41c">Diferenças cruciais ao programar</a>
<ul>
<li><a href="#orgaf06da9">Anatomia básica de um programa em C</a></li>
<li><a href="#org85daa25">Entrada via console</a></li>
<li><a href="#org152a262"><i>Parsing</i> de argumentos de linha de comando</a></li>
</ul>
</li>
<li><a href="#org45efb44">Processo de compilação</a>
<ul>
<li><a href="#org4f26061">O arquivo <code>mkfile</code></a></li>
</ul>
</li>
<li><a href="#org1ff2bc2">Conclusão</a></li>
</ul>
</div>
</div>

<div id="org465fd94" class="figure">
<p><img src="./img/space-glenda.png" alt="space-glenda.png" />
</p>
<p><span class="figure-number">Figura 1: </span>Glenda, mascote do Plan 9, em seu traje espacial para navegar na web.</p>
</div>
<div id="outline-container-org9e9c7c9" class="outline-2">
<h2 id="org9e9c7c9">Introdução</h2>
<div class="outline-text-2" id="text-org9e9c7c9">
<p>
Olá. Neste post, pretendo explorar os aspectos e as dificuldades que obtive ao
programar um pequeno jogo na linguagem C; todavia, este post diz pouco respeito
à linguagem e ao projeto em si, sendo realmente focado no sistema operacional
para o qual decidi desenvolvê-lo.
</p>

<p>
Minha amiga, a Sarah Orlando, adotou para si o desafio da criação de um clone
do Campo Minado (<i>Minesweeper</i>) na linguagem C++, ainda que com foco em estruturas
mais básicas, o que dispensaria o uso de STL ou orientação a objetos. Inspirado
na decisão dela, resolvi adotar o mesmo projeto para o fim-de-semana.
</p>

<p>
Mas afinal, por que facilitar se podemos complicar, não é mesmo? Como já
programo em C e em C++ há um bom tempo, resolvi tentar fazer algo inusitado. Já
fazia um tempo que eu queria desenvolver alguma aplicação simples em C para um
outro sistema operacional: o Plan 9. Se eu pudesse unir o útil ao agradável,
teria um joguinho simples, que requereria nada mais, nada menos que um console
para impressão da sua interface.
</p>

<p>
Este post visa explorar minhas dificuldades e aprendizados que adquiri ao
realizar este projeto. Por não se tratar de algo usual, até mesmo a forma como
o código em C é escrito passa a ser diferente &#x2013; mas falarei mais disso adiante.
</p>

<p>
Já agradeço antecipadamente ao Ricardo Lanziano (<i>arpunk</i>) por ter apontado muitas
direções para mim via Telegram, e também por ter me ensinado muita coisa
interessante sobre o SO. Também agradeço à Sarah Orlando por ter sido a
verdadeira pioneira com este projeto.
</p>
</div>
<div id="outline-container-orge91da29" class="outline-3">
<h3 id="orge91da29">O que é Plan 9?</h3>
<div class="outline-text-3" id="text-orge91da29">

<div id="org7e157df" class="figure">
<p><img src="./img/plan9.png" alt="plan9.png" />
</p>
<p><span class="figure-number">Figura 2: </span>Screenshot do sistema em operação.</p>
</div>

<p>
<i>Plan 9 From Bell Labs</i> é um sistema operacional, fruto de pesquisa do mesmo grupo
que criou o sistema operacional UNIX<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> e a linguagem C. O sistema emergiu no
final dos anos 80, e pode ser visto como uma tentativa de evoluir os conceitos
do UNIX, em uma era onde gráficos e rede passaram a ser utilizados mais
ostensivamente.
</p>

<p>
Ainda que tivesse a promessa de modernização do UNIX, o Plan 9 foi originalmente
desenvolvido em uma época onde a internet como conhecemos (com <i>browsers</i> e outras
ferramentas, hoje utilizadas frequentemente no nosso dia-a-dia) ainda não era
uma realidade. Portanto, o sistema não possui um <i>browser</i> capaz de atender às
demandas modernas. Alguns <i>forks</i> do sistema (como o <i>9front</i>, descrito nas próximas
seções) possuem alguns <i>browsers</i> mais "recentes", porém sem a premissa de
habilitar suporte completo à web contemporânea.
</p>

<p>
O sistema é descrito por seus criadores<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> como um "argumento" em prol de
simplicidade e claridade, sendo um UNIX levado ao extremo. Dentre suas
características marcantes, pode-se citar o <i>Plan 9</i> como um sistema para a criação
e o gerenciamento de um ambiente de computação distribuída, onde máquinas
separadas atuam como terminais, ou servidores de CPU, e até mesmo servidores de
arquivos. Desta forma, as máquinas conectadas funcionam como um <i>cluster</i>, e
compartilham diversos recursos entre si.
</p>

<p>
<i>Plan 9 From Bell Labs</i> é, infelizmente, um sistema já abandonado pelos
desenvolvedores originais. Suas reminescências são, hoje, muito bem-mantidas por
uma comunidade de fãs em um conjunto de <i>forks</i> que, surpreendentemente, são hoje
objetos de pesquisa para resolução de problemas modernos, sobretudo no que tange
a design de sistemas operacionais.
</p>
</div>
</div>
<div id="outline-container-org22a352c" class="outline-3">
<h3 id="org22a352c">Forks do Plan 9</h3>
<div class="outline-text-3" id="text-org22a352c">
<p>
O <i>Plan 9</i> ainda possui alguns <i>forks</i> (ou distribuições) notórios em
funcionamento. Como exemplo, temos:
</p>

<ul class="org-ul">
<li><a href="http://9legacy.org/">9legacy</a>, que visa manter o sistema "original", e apenas aceitar patches
de compatibilidade;</li>
<li><a href="http://www.quanstro.net/plan9/9atom/">9atom</a>, que visa adicionar algumas arquiteturas extras para o kernel e suporte
extra para hardware e alguns sistemas de arquivos;</li>
<li><a href="http://9front.org/">9front</a>, o fork utilizado para os testes do projeto descrito neste artigo, que
visa aceitar patches ostensivos e abarcar uma comunidade de fãs, sendo o fork
mais funcional para computadores modernos;</li>
<li><a href="https://bitbucket.org/inferno-os/inferno-os/">Inferno</a>, um sistema da empresa <i>Vita Nuova</i>, mantido como software livre, afim
de promover uma linguagem de programação específica, para tentar simplificar e
manter a segurança de aplicações: a linguagem <a href="http://www.vitanuova.com/inferno/limbo.html">Limbo</a>;</li>
<li><a href="https://harvey-os.org/">Harvey</a>, um sistema operacional de 64-bit que visa trazer o Plan 9 para um
universo que se adeque aos padrões ANSI e POSIX, e pode ser compilado
utilizando compiladores modernos, como <code>gcc</code> ou <code>clang</code><sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>;</li>
<li><a href="http://jehanne.io/">Jehanne</a>, um <i>fork</i> feito sob a premissa de dar continuidade ao princípio de
simplicidade do Plan 9, e também de simplicidade no design de sistemas
operacionais modernos. Distribuído como software livre, possui bastante
atividade em seu blog, trazendo discussões interessantes para entusiastas de
desenvolvimento de sistemas.</li>
</ul>

<p>
<i>Plan 9</i> possui outros forks, mas estes são, provavelmente, os mais relevantes
da atualidade.
</p>
</div>
</div>
<div id="outline-container-orgc8e370c" class="outline-3">
<h3 id="orgc8e370c">Uso e escolha do 9front</h3>
<div class="outline-text-3" id="text-orgc8e370c">
<p>
Neste projeto, como apontado anteriormente, utilizei o <i>9front</i> para testes,
porque também tenho-o instalado em uma partição extra na minha máquina. A beleza
de ter este tipo de sistema instalado é perceber a facilidade na localização de
recursos do mesmo. Por ser algo tão "oldschool", encontrar material a respeito
do seu uso e do seu funcionamento envolve ler os diversos artigos no diretório
<code>/sys/doc</code> (todos os artigos distribuídos em PostScript, podendo ser compilados
"na hora" e vistos no visualizador de documentos<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>). Para outras situações,
basta utilizar as páginas de manual, as famosas <i>manpages</i>, que funcionam da exata
mesma forma como no Linux<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>.
</p>

<p>
Adicionalmente, preciso ressaltar o quão interessante é a filosofia do
sistema. Os compiladores são modulares e auto-contidos o suficiente, a ponto de
tornar <i>cross-compiling</i> para diversas arquiteturas uma operação completamente
trivial. Ou seja, se seu sistema estiver sendo executado para arquitetura x86,
mas sua arquitetura for x86<sub>64</sub>, você poderá recompilar o <i>Plan 9</i> por completo
(kernel + userland) em <b>menos de cinco minutos</b>. Compare este tempo ao tempo de
compilação do kernel Linux, ainda que compilado com o mínimo de features
possível. Mesmo assim, <i>Plan 9</i> será compilado muito mais rapidamente, e isto
proverá, imediatamente, um sistema completo e pronto para o funcionamento.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfae7b4e" class="outline-2">
<h2 id="orgfae7b4e">Ferramentas de desenvolvimento</h2>
<div class="outline-text-2" id="text-orgfae7b4e">
</div>
<div id="outline-container-orga0c2e65" class="outline-3">
<h3 id="orga0c2e65">Desenvolvimento no Linux</h3>
<div class="outline-text-3" id="text-orga0c2e65">
<p>
A maior parte do desenvolvimento foi feita em meu sistema Void Linux x86<sub>64</sub>, sob
o editor de texto Emacs; afinal, ninguém precisa de algum editor de texto
especial para escrever código algum. Sinto-me confortável utilizando o Emacs
para desenvolvimento, então fiquei seguro ao utilizá-lo.
</p>

<p>
Alguns dos testes foram feitos utilizando uma ferramenta chamada <i>plan9port</i>, que
faz funcionar algumas (não todas) as ferramentas do <i>Plan 9</i> no Linux. Em
especial, o que utilizei foi o compilador <code>9c</code> e o linker <code>9l</code> (que na realidade são
wrappers para compiladores próprios para Linux), e o terminal <code>9term</code> por motivos
estéticos.
</p>

<p>
Para scripts de compilação, utilizei a ferramenta <code>mk</code> do <code>plan9port</code> inicialmente,
mas logo reverti para o <code>make</code>, quando precisei adaptar o sistema de build
utilizando o <code>mk</code> para o <i>Plan 9</i> de verdade. Maiores diferenças serão destacadas
adiante.
</p>
</div>
</div>
<div id="outline-container-org6a10b0d" class="outline-3">
<h3 id="org6a10b0d">Desenvolvimento no <i>9front</i></h3>
<div class="outline-text-3" id="text-org6a10b0d">
<p>
Tenho o <i>9front</i> instalado tanto de forma nativa quanto em um drive virtual,
bootável via QEMU dentro do Void Linux<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>. Após o final do desenvolvimento
usando <code>plan9port</code> no Linux, bastou trazer o código para o QEMU e, em seguida,
para o 9front nativo, e o projeto funcionou com mudanças mínimas que não
afetaram o build para Linux com <code>plan9port</code>. O restante do trabalho baseou-se
apenas em adequar o arquivo <code>mkfile</code> para que funcionasse no 9front (mais sobre
este arquivo será dito a seguir).
</p>
</div>
</div>
</div>
<div id="outline-container-orgaeed476" class="outline-2">
<h2 id="orgaeed476">Estrutura do projeto</h2>
<div class="outline-text-2" id="text-orgaeed476">
<p>
Neste momento, destacarei alguns pontos com relação aos arquivos de projeto
criados, e também da organização em termos de hierarquia e uso dos mesmos.
</p>


<div id="orgf58f304" class="figure">
<p><img src="./img/9mine.gif" alt="9mine.gif" />
</p>
<p><span class="figure-number">Figura 3: </span>O jogo em funcionamento, no Linux, sob o plan9port.</p>
</div>
</div>
<div id="outline-container-orgf5ca64d" class="outline-3">
<h3 id="orgf5ca64d">Arquivos</h3>
<div class="outline-text-3" id="text-orgf5ca64d">
<p>
O projeto possui apenas três arquivos relevantes:
</p>

<ul class="org-ul">
<li><code>9mine.c</code></li>
<li><code>mkfile</code></li>
<li><code>Makefile</code></li>
</ul>

<p>
Onde <code>9mine.c</code> é o arquivo de código em C, <code>mkfile</code> é o arquivo de configuração e
<i>build</i> para Plan 9, e <code>Makefile</code> é o arquivo de build para o Linux.
</p>
</div>
</div>
<div id="outline-container-org3c830f1" class="outline-3">
<h3 id="org3c830f1">Método de compilação</h3>
<div class="outline-text-3" id="text-org3c830f1">
<p>
Para compilar o projeto, foram utilizados tanto <code>make</code> (Linux/plan9port) quanto
<code>mk</code> (Plan 9).
</p>
</div>
<div id="outline-container-orgbc29063" class="outline-4">
<h4 id="orgbc29063"><code>make</code></h4>
<div class="outline-text-4" id="text-orgbc29063">
<p>
Inicialmente, meu objetivo era utilizar apenas ferramentas do <code>plan9port</code> no
Linux, de forma a emular completamente um ambiente de compilação para o
Plan 9. Acontece que o <code>plan9port</code> não visa permitir exatamente isto. Algumas das
utilidades da compilação do Plan 9, como a escrita de um script de compilação
que seja agnóstico em termos de arquitetura do processador, não foram portadas
para o Linux, pelo motivo óbvio de elas serem habilitadas por dependências
intrínsecas ao sistema, que logo mais descreverei.
</p>

<p>
Como o processo de compilação no Linux envolvia um sistema de prototipagem
rápida, e não demandava preocupação com arquitetura do processador, ou mesmo com
processo de instalação no sistema, optei por utilizar a ferramenta de scripting
para build padrão do Linux, o programa <code>make</code>.
</p>
</div>
</div>
<div id="outline-container-org97bd00a" class="outline-4">
<h4 id="org97bd00a"><code>mk</code></h4>
<div class="outline-text-4" id="text-org97bd00a">
<p>
Esta é a ferramenta padrão para facilitação de builds no Plan 9, e também é
ostensivamente utilizada na manutenção de arquivos e na hierarquia do
sistema<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>. Segundo a documentação oficial, <code>mk</code> foi criado para interagir
diretamente com o shell oficial do Plan 9, o <code>rc</code>, possibilitando a execução de
tarefas como manutenção, e até mesmo execução de ações em paralelo, ao explorar
um ambiente com múltiplos processadores, o que é respaldado pela ideia de um
sistema distribuído e com acesso a dispositivos em máquinas remotas.
</p>

<p>
Utilizo esta aplicação no projeto para possibilitar o suporte e a distribuição
do software para qualquer fork do <i>Plan 9</i>. Através dele, é possível tanto
compilar quanto instalar o jogo aqui discutido.
</p>
</div>
</div>
</div>
<div id="outline-container-org39ede08" class="outline-3">
<h3 id="org39ede08">Controle de versão e manutenção de patches do sistema</h3>
<div class="outline-text-3" id="text-org39ede08">
<p>
Na realidade, nenhum fork do <i>Plan 9</i> possui um bom sistema de controle de
versão. Há um script comunitário que funciona de forma similar ao <code>git</code> mas que,
primariamente, não passa de um wrapper para o <code>hget</code> (similar ao <code>wget</code>)<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>.
</p>

<p>
Existe uma ferramenta comunitária de suporte para Mercurial, também lá chamada
de <code>hg</code>, mas que não utilizei, por não ter usado Mercurial para controle de
versão. Há rumores de que esta ferramenta "dá para o gasto", mas é insuficiente
em muitos requisitos. Todavia, é a ferramenta primária relacionada a updates do
sistema no <i>9front</i>.
</p>

<p>
Ainda que esta descrição de sistemas de controle de versão para Plan 9 pareça
absurda, lembre-se de que este é um sistema que predata a internet como a
conhecemos, e com uma base de fãs que preferem o jeito "oldschool". Sendo assim,
seria mais comum falar em <i>patches</i> na forma de diffs, vindos por e-mail, e que
são incorporados aos arquivos utilizando uma ferramenta para tal. Um projeto de
integração de controle de versão com o Plan 9 provavelmente valeria-se da
ferramenta utilizada para isto. Portanto, fica bem claro que software de
controle de versão no Plan 9 deveria ser preferencialmente não-monolítico.
</p>

<p>
Caso você esteja curioso com relação à forma como o sistema é, normalmente,
"atualizado", o procedimento passa pela montagem de um diretório remoto,
conectado aos servidores dos mantenedores do fork utilizado, através do
protocolo <code>9p</code>, que também é uma das características-estrela do Plan 9, na qual,
infelizmente, não vou me aprofundar aqui<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup>.
</p>
</div>
</div>
</div>
<div id="outline-container-org268f41c" class="outline-2">
<h2 id="org268f41c">Diferenças cruciais ao programar</h2>
<div class="outline-text-2" id="text-org268f41c">
<p>
O sistema é radicalmente diferente na forma como sugere a interação do
programador com a biblioteca-padrão de C. Nesta seção, mostrarei alguns
programas básicos com algumas <i>features</i> que julguei serem relevantes.
</p>
</div>
<div id="outline-container-orgaf06da9" class="outline-3">
<h3 id="orgaf06da9">Anatomia básica de um programa em C</h3>
<div class="outline-text-3" id="text-orgaf06da9">
<p>
Como antes dito, um programa básico em C para o <i>Plan 9</i> pode ser dramaticamente
diferente do que vemos hoje para Windows, Linux e OS X. Abaixo, temos um "Hello,
world!" bem simples.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #e55c7a;">#include</span> <span style="color: #f5c791;">&lt;u.h&gt;</span>
<span style="color: #e55c7a;">#include</span> <span style="color: #f5c791;">&lt;libc.h&gt;</span>

<span style="color: #62D2DB;">void</span>
<span style="color: #0bc9cf;">main</span>(<span style="color: #62D2DB;">void</span>)
{
    print(<span style="color: #f5c791;">"Hello, world!\n"</span>);
    exits(<span style="color: #f5c791;">0</span>);
}
</pre>
</div>

<p>
Leitores acostumados com ANSI C poderão assustar um pouco com o exemplo. Como
pode ser visto, apesar de estarmos imprimindo algo na tela, não há sequer uma
sombra remota de <code>stdio.h</code> ou de <code>printf</code>, pois estas são funções que não existem no
<i>Plan 9</i><sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>. Mas engana-se quem acha que não são suficientes: ao invés da
implementação de um padrão enorme, o foco está em deixar as coisas o mais
simples possível para o programador.
</p>

<p>
Os cabeçalhos <code>u.h</code> e <code>libc.h</code> são cabeçalhos padrões no Plan 9, e já englobam uma
quantidade enorme de coisas específicas. Deve-se incluir estes cabeçalhos nesta
exata ordem para evitar problemas de <i>linking</i>.
</p>

<p>
A função <code>print(3)</code><sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup> funciona da exata mesma maneira que <code>printf</code>, porém com
algumas diferenças: <i>Plan 9</i> suporta unicode <i>out-of-the-box</i>, então há flags para o
tipo <i>Rune</i>, por exemplo, que simboliza um caractere UTF-8.
</p>

<p>
<code>exits(3)</code><sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup> é a função comum para encerramento de um processo qualquer,
recebendo, como parâmetro, uma constante de caracteres (de tamanho máximo
<code>ERRLEN</code>), especificando brevemente o motivo para a saída do processo. Veja,
porém, que, ao contrário de sistemas Unix-like convencionais, a função de ponto
de entrada (<code>main</code>) não possui valor de retorno. Portanto, o uso de <code>exits(3)</code> é
opcional, no caso apresentado. Também, passar um ponteiro nulo para esta
função (no caso, o valor <code>0</code> ou o macro <code>nil</code>) indica que o processo foi terminado
normalmente.
</p>
</div>
</div>
<div id="outline-container-org85daa25" class="outline-3">
<h3 id="org85daa25">Entrada via console</h3>
<div class="outline-text-3" id="text-org85daa25">
<p>
<i>Plan 9</i> não possui um equivalente direto a <code>scanf(3)</code><sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>. Ao invés disso,
entrada a partir do console é uma atividade delegada à biblioteca
<code>libbio</code>. Enquanto isto parece algo não-usual, é uma prática que compactua com a
filosofia do sistema, que envolve levar a filosofia UNIX ao extremo: se tudo é
um arquivo, e arquivos são lidos como <i>streams</i>, então a entrada do console também
poderá ser tratada como um <i>stream<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup></i>.
</p>

<p>
Ademais, <code>libbio</code> trata entrada e saída para arquivos no formato de um <i>buffer</i>,
alocado na estrutura <code>Biobuf</code>. Basta abrir o <i>buffer</i> para leitura com <code>stdin</code>:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #e55c7a;">#include</span> <span style="color: #f5c791;">&lt;u.h&gt;</span>
<span style="color: #e55c7a;">#include</span> <span style="color: #f5c791;">&lt;libc.h&gt;</span>
<span style="color: #e55c7a;">#include</span> <span style="color: #f5c791;">&lt;bio.h&gt;</span> <span style="color: #454459;">/* </span><span style="color: #454459;">Cabe&#231;alho da libbio</span><span style="color: #454459;"> */</span>


<span style="color: #454459;">/* </span><span style="color: #454459;">No ponto de entrada da aplica&#231;&#227;o</span><span style="color: #454459;"> */</span>
<span style="color: #62D2DB;">void</span>
<span style="color: #0bc9cf;">main</span>(<span style="color: #62D2DB;">void</span>)
{
    <span style="color: #454459;">/* </span><span style="color: #454459;">Estrutura do buffer</span><span style="color: #454459;"> */</span>
    <span style="color: #62D2DB;">Biobuf</span> <span style="color: #7CF083;">bstdin</span>;

    <span style="color: #454459;">/* </span><span style="color: #454459;">Abertura do buffer. O argumento '0' indica stdin</span><span style="color: #454459;"> */</span>
    <span style="color: #9d81ba;">if</span>(Binit(&amp;bstdin, <span style="color: #f5c791;">0</span>, OREAD) == Beof) {
        fprint(<span style="color: #f5c791;">2</span>, <span style="color: #f5c791;">"Erro ao conectar stdin a bio: %r"</span>);
        exits(<span style="color: #f5c791;">"Binit"</span>);
    }

    <span style="color: #454459;">/* </span><span style="color: #454459;">Lendo uma linha a partir de stdin</span><span style="color: #454459;"> */</span>
    <span style="color: #62D2DB;">char</span> *<span style="color: #7CF083;">str</span>;
    <span style="color: #62D2DB;">int</span>   <span style="color: #7CF083;">len</span>;

    str = Brdline(&amp;bstdin, <span style="color: #f5c791;">10</span>); <span style="color: #454459;">/* </span><span style="color: #454459;">10 = \n</span><span style="color: #454459;"> */</span>
    len = Blinelen(&amp;bstdin);

    <span style="color: #454459;">/* </span><span style="color: #454459;">remove o caractere de fim-de-linha na string</span><span style="color: #454459;"> */</span>
    <span style="color: #9d81ba;">if</span>(str) {
        str[--len] = <span style="color: #f5c791;">'\0'</span>;
    }

    print(<span style="color: #f5c791;">"Lida a frase \"%s\" de tamanho %d\n"</span>, str, len);

    <span style="color: #454459;">/* </span><span style="color: #454459;">Fechamento do buffer</span><span style="color: #454459;"> */</span>
    Bterm(&amp;bstdin);
    exits(<span style="color: #f5c791;">0</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org152a262" class="outline-3">
<h3 id="org152a262"><i>Parsing</i> de argumentos de linha de comando</h3>
<div class="outline-text-3" id="text-org152a262">
<p>
Normalmente, quando escrevemos uma aplicação em C/C++, sabemos que podemos
utilizar <code>argc</code> e <code>argv</code>, passáveis como parâmetro para <code>main</code>, para recuperar os
argumentos passados via console para nossa aplicação. No Plan 9, isto não é
diferente.
</p>

<p>
Como meu jogo tinha um modo debug, eu precisava de uma flag <code>-d</code> que pudesse ser
passada via console. Assim, minha primeira aproximação para este problema foi a
forma mais ingênua:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #62D2DB;">void</span>
<span style="color: #0bc9cf;">main</span>(<span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">argc</span>, <span style="color: #62D2DB;">char</span> **<span style="color: #7CF083;">argv</span>)
{
    <span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">i</span>;
    <span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">debug</span> = <span style="color: #f5c791;">0</span>;
    <span style="color: #9d81ba;">for</span>(i = <span style="color: #f5c791;">1</span>; i &lt; argc; i++) {
        <span style="color: #9d81ba;">if</span>(<span style="color: #e55c7a;">!</span>strcmp(argv[i], <span style="color: #f5c791;">"-d"</span>)) {
            debug = <span style="color: #f5c791;">1</span>;
            <span style="color: #9d81ba;">break</span>;
        }
    }

    <span style="color: #9d81ba;">if</span>(debug) {
        print(<span style="color: #f5c791;">"Got a debug flag!\n"</span>);
    }

    exits(<span style="color: #f5c791;">0</span>);
}
</pre>
</div>

<p>
Todavia, o Plan 9 já tem algo para te ajudar com isso, na forma de macros! Como
muito bem apontado pelo Ricardo Lanziano, existe uma forma muito mais simples de
lidar com este problema. Deixo a interpretação para o leitor:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #62D2DB;">void</span>
<span style="color: #0bc9cf;">main</span>(<span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">argc</span>, <span style="color: #62D2DB;">char</span> **<span style="color: #7CF083;">argv</span>)
{
    <span style="color: #62D2DB;">int</span> <span style="color: #7CF083;">debug</span> = <span style="color: #f5c791;">0</span>;

    ARGBEGIN {
        <span style="color: #9d81ba;">case</span> <span style="color: #f5c791;">'d'</span>:
            debug = <span style="color: #f5c791;">1</span>;
            <span style="color: #9d81ba;">break</span>;
    } ARGEND;

    <span style="color: #9d81ba;">if</span>(debug) {
        print(<span style="color: #f5c791;">"Got a debug flag!\n"</span>);
    }

    exits(<span style="color: #f5c791;">0</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org45efb44" class="outline-2">
<h2 id="org45efb44">Processo de compilação</h2>
<div class="outline-text-2" id="text-org45efb44">

<div id="org0f73241" class="figure">
<p><img src="./img/9front-qemu.png" alt="9front-qemu.png" />
</p>
<p><span class="figure-number">Figura 4: </span>9front sob o QEMU, executando o projeto 9mine no console.</p>
</div>

<p>
O processo de compilação no Linux é <i>straightforward</i>: Provido que você tenha o
<code>plan9port</code> instalado e configurado, digitar <code>make</code> no diretório <code>src/</code> do projeto
compilará a aplicação. Não foi incluído nenhum <i>target</i> de instalação, uma vez que
o objetivo primário é dar atenção ao Plan 9.
</p>

<p>
No <i>9front</i>, provido que você já tenha o diretório do projeto clonado em sua
máquina (vide a seção de controle de versão), basta ir ao diretório <code>src/</code> e
digitar <code>mk</code> para gerar o binário. Em seguida, digitar <code>mk install</code> instalará o
binário sob o diretório <code>/bin/games</code> da sua arquitetura. O jogo, em si, será
invocável no console, com o comando <code>games/9mine</code><sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup>.
</p>
</div>
<div id="outline-container-org4f26061" class="outline-3">
<h3 id="org4f26061">O arquivo <code>mkfile</code></h3>
<div class="outline-text-3" id="text-org4f26061">
<p>
O arquivo <code>mkfile</code> não é particularmente complicado ou muito diferente de um
arquivo <code>Makefile</code> como conhecemos; porém, seu design foi feito sob uma premissa
de maior integração com o sistema operacional, o que ocasiona alguns pequenos
truques pré-preparados e muito interessantes<sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>.
</p>

<p>
Abaixo, coloco uma cópia direta do arquivo <code>mkfile</code> do <code>9mine</code>, cuja ação
descreverei a seguir.
</p>

<div class="org-src-container">
<pre class="src src-makefile">&lt;/$objtype/mkfile

<span style="color: #7CF083;">BIN</span>=/$objtype/bin/games

<span style="color: #0bc9cf;">9mine</span>:  <span style="color: #f5c791;">9mine</span>.$<span style="color: #0D9C94;">O</span>
         $LD -o $target $prereq

<span style="color: #0bc9cf;">install</span>: <span style="color: #f5c791;">9mine</span>
          mv <span style="color: #f5c791;">9mine</span> $BIN

<span style="color: #0bc9cf;">%.$</span><span style="color: #0bc9cf;">O</span>:    %.c
$CC $CFLAGS $stem.c
</pre>
</div>

<p>
Este script é necessariamente independente de arquitetura, porque "herda" o
conteúdo do arquivo <code>/$objtype/mkfile</code>, que é suprido pelo sistema. <code>$objtype</code> é uma
variável de ambiente que especifica a arquitetura nativa para a qual pretende-se
compilar a aplicação. Como o sistema estava sendo executado para uma arquitetura
386, o simples ato de invocar <code>mk</code> no diretório cria um arquivo <code>9mine.8</code>, similar a
um arquivo <code>.o</code> no Linux. Este arquivo, então, será linkado e transformado no
binário de nome <code>9mine</code>.
</p>

<p>
O interessante deste método é que, como ele depende de uma variável de ambiente,
o mero ato de modificá-la já habilita suporte a compilação <i>cross-platform</i>. Plan
9 tem compiladores de C extremamente compactos e que funcionam para diversas
arquiteturas, o que torna esta uma operação fácil<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup>.
</p>

<p>
Por exemplo, suponhamos que estamos compilando uma aplicação em C para ser
executada em um Raspberry Pi 2 ou 3. A arquitetura destes dispositivos é ARM;
além disso, é possível compilar o sistema Plan 9 para ARM<sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup>. Dito isto, a
partir do seu computador pessoal de qualquer arquitetura, que esteja executando
o Plan 9, é possível produzir um binário compatível com a arquitetura ARM,
utilizando o seguinte comando:
</p>

<div class="org-src-container">
<pre class="src src-rc"><span style="color: #7CF083;">objtype</span>=arm mk
</pre>
</div>

<p>
Isto fará override da variável <code>$objtype</code> para o próximo comando, que é <code>mk</code>, e
utilizará variáveis e compiladores apropriados para a arquitetura-alvo. Sendo
assim, o script criará um objeto sob o nome <code>9mine.5</code>, onde o número após o ponto
diz respeito à arquitetura-alvo<sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>.
</p>
</div>
</div>
</div>
<div id="outline-container-org1ff2bc2" class="outline-2">
<h2 id="org1ff2bc2">Conclusão</h2>
<div class="outline-text-2" id="text-org1ff2bc2">
<p>
Certa vez, um contato me disse que seria interessante, ao longo da minha vida,
absorver conhecimento sobre diversos sistemas UNIX-like, sempre procurando saber
mais sobre eles, para que não houvesse surpresa ao migrar de um sistema para
outro. Ainda que o Plan 9 não possua uso expressivo na indústria<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup>, fica
evidente a preocupação com arquitetura e clareza no desenvolvimento deste
sistema operacional, o que vejo como um exemplo valioso para mim.
</p>

<p>
Acredito que o Plan 9 possua seus usos, mesmo em um ambiente moderno. Nesta nova
onda de uma internet onde operações parecem independer de servidores
centralizados, um sistema operacional de trinta anos atrás parece apontar por
veredas de bom uso e viabilidade.
</p>

<p>
Ademais, o código e a arquitetura do Plan 9 são sinônimos de excelência. O
sistema visa buscar e evangelizar código legível, escrito em C, sob boas
práticas estritas e sob a Filosofia UNIX, mostrando que desenvolvimento de
software não precisa ser esta "bagunça" que vivemos atualmente. A fórmula para
isto, claro, envolve não apenas estudo, mas também apresentação de exemplos,
da mesma forma como o <i>Plan 9 From Bell Labs</i> procurou ser.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Notas de Rodap&eacute;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
O <a href="https://en.wikipedia.org/wiki/Unix">sistema operacional UNIX</a> foi um sistema originalmente projetado como
uma plataforma conveniente para programadores, de forma a facilitar o
desenvolvimento de software. A arquitetura baseia-se na famosa filosofia
homônima, de onde surgiram máximas como "tudo é um arquivo" ou "faça programas
que façam uma única coisa, e que façam-na apropriadamente". A extrema
modularidade e simplicidade revelou-se conveniente em termos de projeto e
arquitetura de sistemas operacionais, apadrinhando sistemas modernos em sua
arquitetura (os famosos sistemas UNIX-like, como Linux, BSD ou OS X).
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Mais informações sobre os objetivos do Plan 9 podem ser vistas na página
de manual apropriada de introdução, em <a href="http://man.9front.org/1/intro"><code>intro(1)</code></a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Se você estiver procurando um bom projeto de software livre para
contribuir ou estudar o código, recomendo dar uma olhada no Harvey. Você pode
acessar o código-fonte <a href="https://github.com/Harvey-OS/harvey">aqui</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Esta é uma feature interessante que acredito poder elaborar. Os artigos
encontram-se, em maioria, em arquivos com a extensão <code>.ps</code>. É necessário navegar
até o diretório <code>/sys/doc</code> no terminal, e então listar os arquivos no
diretório. Logo após, basta marcar o nome do arquivo utilizando o mouse, dar um
clique com o botão do meio, e então selecionar <code>plumb</code>; imediatamente, o programa
<code>page</code> será aberto, com o artigo em questão no formato renderizado. Isto é
interessante, pois não funciona apenas para arquivos PostScript; quaisquer
arquivos poderiam ser abertos em seus programas adequados, talvez até mesmo
compilados automaticamente, utilizando apenas esta feature. 
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Não posso negar, estas não foram minhas únicas fontes de
informação. Anteriormente, citei que o Ricardo Lanziano me ajudou em muitas
coisas com relação ao funcionamento e à operação do sistema, mas também foi de
grande ajuda a leitura da seção de <a href="http://fqa.9front.org/fqa.html"><i>Frequently Questioned Answers</i> do 9front</a>.
Nota: esta página leva a sério o ato de ser humorística e politicamente
incorreta, mas não deixa de conter informação útil.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Caso o leitor queira realizar uma instalação do 9front no QEMU como fiz,
poderá consultar a <a href="http://fqa.9front.org/fqa3.html#3.3.1">página de dúvidas do 9front</a>, que possui instruções explícitas
de como fazê-lo. Nesta mesma seção, também há instruções para instalação do
9front em hardware "real".
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Para saber mais a respeito desta ferramenta, recomendo ler
<a href="http://www.vitanuova.com/inferno/papers/mk.pdf">o artigo do <code>mk</code></a>, que já vem incluso no diretório <code>/sys/doc</code> do sistema.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Acredito que não seja muito adequado colocar isto aqui como nota de
rodapé, mas, na falta de um lugar mais adequado, deixarei aqui para futura
consulta. O método de instalação envolve montar localmente a máquina remota dos
servidores do <i>9front</i>, e então copiar o script de <code>git</code> localmente. Isto envolve
dois comandos: <code>9fs 9front; cp /n/extra/rc/git $home/bin/rc/</code>. 
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
As instruções completas de como compilar o <i>9front</i> a partir do
código-fonte <a href="http://fqa.9front.org/fqa5.html">encontram-se aqui</a>. Caso você queira saber mais sobre o <code>9p</code> (ou o
<code>9fs</code>), encontrará informações relevantes <a href="https://plan9.io/sys/doc/net/net.pdf">neste paper</a>, que visa endereçar a
organização das redes no Plan 9.
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Na realidade, o Plan 9 possui, sim, implementações para estas funções
mais triviais, mas elas não são normalmente utilizadas no design original do
sistema, e também não são preferidas pelos desenvolvedores ativos do
mesmo. Sendo assim, optei por manter o uso da linguagem C no Plan 9 de forma
"pura", ao invés de forçar a compatibilidade entre o Plan 9 e outros sistemas.
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Veja <a href="http://man.9front.org/2/print">print(2) nos manuais online</a> do 9front.
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Veja <a href="http://man.9front.org/2/exits">exits(2) nos manuais online</a> do 9front.
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Veja <a href="https://linux.die.net/man/3/scanf">scanf(3) nos manuais online</a> do Linux.
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Caso você desconheça o conceito de <i>streams</i> do UNIX, poderá achar o artigo
do Dennis Ritchie sobre <i>streams</i> <a href="https://doi.org/10.1002/j.1538-7305.1984.tb00071.x">aqui</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Note a mudança evidente na forma como binários se comportam no Plan 9. O
fato de um binário chamado <code>9mine</code> estar em um subdiretório de <code>bin</code> significa que
este continuará sendo invocável, mediante a informação de em qual subdiretório
ele se encontra. Isto evidencia o uso de <i>namespaces</i> para hierarquia de arquivos
no sistema. Para mais informações, recomendo consultar <a href="https://9p.io/sys/doc/names.pdf">este maravilhoso paper</a>
dos desenvolvedores originais do sistema, que explicita a forma como a
hierarquia dos <i>namespaces</i> funciona, bem como seus usos.
</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Recomendo, também, a leitura do artigo <a href="https://plan9.io/sys/doc/mkfiles.pdf">Plan 9 Mkfiles</a>, igualmente
incluído no sistema, que possui um material completo para uso de <code>mkfile</code>.
</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Para uma explicação completa das arquiteturas suportadas pelos
compiladores do Plan 9, veja a <a href="http://man.cat-v.org/plan_9/1/2c">manpage relacionada</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
As instruções de compilação do <i>9front</i> para Raspberry Pi <a href="http://fqa.9front.org/appendixj.html">estão aqui</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Uma descrição mais aprofundada dos compiladores de C do Plan 9 pode ser
vista <a href="https://9p.io/sys/doc/compiler.html">neste artigo</a>, e descrições aprofundadas do uso destes compiladores podem
ser vistas <a href="https://plan9.io/sys/doc/comp.pdf">neste outro artigo</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Bom&#x2026; não é bem assim, não é? Recentemente, a Microsoft realizou um
patch que <a href="https://devblogs.microsoft.com/commandline/whats-new-for-wsl-in-windows-10-version-1903/">adiciona a funcionalidade</a> de abrir o Windows Explorer em um subsistema
Linux que esteja rodando no Windows 10. A magia toda ocorre sob a utilização de
um servidor de arquivos local, que utiliza o protocolo <code>9p</code>, nativo do Plan 9,
para comunicação entre a máquina "real" e o subsistema. Aparentemente, boas
ideias não morrem.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<h3><a href="../">De volta à página anterior</a></h3>
</div>
</body>
</html>
